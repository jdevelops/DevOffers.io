{"ast":null,"code":"import _regeneratorRuntime from \"C:/Frontend22/Projects/inz/DevOffers.io/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Frontend22/Projects/inz/DevOffers.io/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Frontend22/Projects/inz/DevOffers.io/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\r\n     * Keeps track of the async client initialization.\r\n     * When null or not yet resolved the auth state is `unknown`\r\n     * Once resolved the the auth state is known and it's save to call any further client methods.\r\n     * Keep extra care to never reject or throw uncaught errors\r\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n\n      return this.initializePromise;\n    }\n    /**\r\n     * IMPORTANT:\r\n     * 1. Never throw in this method, as it is called from the constructor\r\n     * 2. Never return a session from this method as it would be cached over\r\n     *    the whole lifetime of the client\r\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$this$_getSessi, data, error, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.initializePromise) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.initializePromise);\n\n              case 2:\n                _context.prev = 2;\n\n                if (!(this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n                  _context.next = 19;\n                  break;\n                }\n\n                _context.next = 6;\n                return this._getSessionFromUrl();\n\n              case 6:\n                _yield$this$_getSessi = _context.sent;\n                data = _yield$this$_getSessi.data;\n                error = _yield$this$_getSessi.error;\n\n                if (!error) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 12;\n                return this._removeSession();\n\n              case 12:\n                return _context.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 13:\n                session = data.session, redirectType = data.redirectType;\n                _context.next = 16;\n                return this._saveSession(session);\n\n              case 16:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n                if (redirectType === 'recovery') {\n                  this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 19:\n                _context.next = 21;\n                return this._recoverAndRefresh();\n\n              case 21:\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](2);\n\n                if (!isAuthError(_context.t0)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: _context.t0\n                });\n\n              case 28:\n                return _context.abrupt(\"return\", {\n                  error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n                });\n\n              case 29:\n                _context.prev = 29;\n\n                this._handleVisibilityChange();\n\n                return _context.finish(29);\n\n              case 32:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 24, 29, 32]]);\n      }));\n    }\n    /**\r\n     * Creates a new user.\r\n     *\r\n     * Be aware that if a user account exists in the system you may get back an\r\n     * error message that attempts to hide this information from the user.\r\n     *\r\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n     * @returns A user if the server has \"autoconfirm\" OFF\r\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, phone, _password, _options, _res, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context2.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n                _context2.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password,\n                    data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                      captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res = res, data = _res.data, error = _res.error;\n\n                if (!(error || !data)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                session = data.session;\n                user = data.user;\n\n                if (!data.session) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                _context2.next = 26;\n                return this._saveSession(data.session);\n\n              case 26:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 27:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!isAuthError(_context2.t0)) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context2.t0\n                });\n\n              case 34:\n                throw _context2.t0;\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 30]]);\n      }));\n    }\n    /**\r\n     * Log in an existing user with an email and password or phone and password.\r\n     *\r\n     * Be aware that you may get back an error message that will not distingish\r\n     * between the cases where the account does not exist or that the\r\n     * email/phone and password combination is wrong or that the account can only\r\n     * be accessed via social login.\r\n     */\n\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context3.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n                _context3.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password2,\n                    data: (_b = _options2 === null || _options2 === void 0 ? void 0 : _options2.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                      captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res2 = res, data = _res2.data, error = _res2.error;\n\n                if (!(error || !data)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                if (!data.session) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.next = 24;\n                return this._saveSession(data.session);\n\n              case 24:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 25:\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                if (!isAuthError(_context3.t0)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context3.t0\n                });\n\n              case 32:\n                throw _context3.t0;\n\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\r\n     * Log in an existing user via a third-party provider.\r\n     */\n\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._removeSession();\n\n              case 2:\n                return _context4.abrupt(\"return\", this._handleProviderSignIn(credentials.provider, {\n                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\r\n     * Log in a user using magiclink or a one-time password (OTP).\r\n     *\r\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n     *\r\n     * Be aware that you may get back an error message that will not distinguish\r\n     * between the cases where the account does not exist or, that the account\r\n     * can only be accessed via social login.\r\n     */\n\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var email, options, _yield$_request, error, phone, _options3, _yield$_request2, _error;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                email = credentials.email, options = credentials.options;\n                _context5.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n\n              case 7:\n                _yield$_request = _context5.sent;\n                error = _yield$_request.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context5.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _options3 = credentials.options;\n                _context5.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                    create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                    gotrue_meta_security: {\n                      captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                    }\n                  }\n                });\n\n              case 14:\n                _yield$_request2 = _context5.sent;\n                _error = _yield$_request2.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _error\n                });\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n\n              case 20:\n                _context5.prev = 20;\n                _context5.t0 = _context5[\"catch\"](0);\n\n                if (!isAuthError(_context5.t0)) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context5.t0\n                });\n\n              case 24:\n                throw _context5.t0;\n\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 20]]);\n      }));\n    }\n    /**\r\n     * Log in a user given a User supplied OTP received via mobile.\r\n     */\n\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _yield$_request3, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context6.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                  headers: this.headers,\n                  body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                      captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                    }\n                  }),\n                  redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request3 = _context6.sent;\n                data = _yield$_request3.data;\n                error = _yield$_request3.error;\n\n                if (!error) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                throw 'An error occurred on token verification.';\n\n              case 12:\n                session = data.session;\n                user = data.user;\n\n                if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._saveSession(session);\n\n              case 17:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 18:\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 21:\n                _context6.prev = 21;\n                _context6.t0 = _context6[\"catch\"](0);\n\n                if (!isAuthError(_context6.t0)) {\n                  _context6.next = 25;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context6.t0\n                });\n\n              case 25:\n                throw _context6.t0;\n\n              case 26:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 21]]);\n      }));\n    }\n    /**\r\n     * Attempts a single-sign on using an enterprise Identity Provider. A\r\n     * successful SSO attempt will redirect the current page to the identity\r\n     * provider authorization page. The redirect URL is implementation and SSO\r\n     * protocol specific.\r\n     *\r\n     * You can use it by providing a SSO domain. Typically you can extract this\r\n     * domain by asking users for their email address. If this domain is\r\n     * registered on the Auth instance the redirect will use that organization's\r\n     * currently active SSO Identity Provider for the login.\r\n     *\r\n     * If you have built an organization-specific login page, you can use the\r\n     * organization's SSO Identity Provider UUID directly instead.\r\n     *\r\n     * This API is experimental and availability is conditional on correct\r\n     * settings on the Auth service.\r\n     *\r\n     * @experimental\r\n     */\n\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context7.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                  body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                    provider_id: params.providerId\n                  } : null), 'domain' in params ? {\n                    domain: params.domain\n                  } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                  }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                      captcha_token: params.options.captchaToken\n                    }\n                  } : null), {\n                    skip_http_redirect: true\n                  }),\n                  headers: this.headers,\n                  xform: _ssoResponse\n                });\n\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                if (!isAuthError(_context7.t0)) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 12:\n                throw _context7.t0;\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 8]]);\n      }));\n    }\n    /**\r\n     * Returns the session, refreshing it if necessary.\r\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n     */\n\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.initializePromise;\n\n              case 2:\n                currentSession = null;\n\n                if (!this.persistSession) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                _context8.next = 6;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 6:\n                maybeSession = _context8.sent;\n\n                if (!(maybeSession !== null)) {\n                  _context8.next = 14;\n                  break;\n                }\n\n                if (!this._isValidSession(maybeSession)) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                currentSession = maybeSession;\n                _context8.next = 14;\n                break;\n\n              case 12:\n                _context8.next = 14;\n                return this._removeSession();\n\n              case 14:\n                _context8.next = 17;\n                break;\n\n              case 16:\n                currentSession = this.inMemorySession;\n\n              case 17:\n                if (currentSession) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n                if (hasExpired) {\n                  _context8.next = 22;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: currentSession\n                  },\n                  error: null\n                });\n\n              case 22:\n                _context8.next = 24;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 24:\n                _yield$this$_callRefr = _context8.sent;\n                session = _yield$this$_callRefr.session;\n                error = _yield$this$_callRefr.error;\n\n                if (!error) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 29:\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\r\n     * Gets the current user details if there is an existing session.\r\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _yield$this$getSessio, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n\n                if (jwt) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                _context9.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio = _context9.sent;\n                data = _yield$this$getSessio.data;\n                error = _yield$this$getSessio.error;\n\n                if (!error) {\n                  _context9.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                // Default to Authorization header if there is no existing session\n                jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n\n              case 10:\n                _context9.next = 12;\n                return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  jwt: jwt,\n                  xform: _userResponse\n                });\n\n              case 12:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 15:\n                _context9.prev = 15;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!isAuthError(_context9.t0)) {\n                  _context9.next = 19;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context9.t0\n                });\n\n              case 19:\n                throw _context9.t0;\n\n              case 20:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 15]]);\n      }));\n    }\n    /**\r\n     * Updates user data, if there is a logged in user.\r\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request4, data, userError;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio2 = _context10.sent;\n                sessionData = _yield$this$getSessio2.data;\n                sessionError = _yield$this$getSessio2.error;\n\n                if (!sessionError) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                throw sessionError;\n\n              case 8:\n                if (sessionData.session) {\n                  _context10.next = 10;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 10:\n                session = sessionData.session;\n                _context10.next = 13;\n                return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  body: attributes,\n                  jwt: session.access_token,\n                  xform: _userResponse\n                });\n\n              case 13:\n                _yield$_request4 = _context10.sent;\n                data = _yield$_request4.data;\n                userError = _yield$_request4.error;\n\n                if (!userError) {\n                  _context10.next = 18;\n                  break;\n                }\n\n                throw userError;\n\n              case 18:\n                session.user = data.user;\n                _context10.next = 21;\n                return this._saveSession(session);\n\n              case 21:\n                this._notifyAllSubscribers('USER_UPDATED', session);\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    user: session.user\n                  },\n                  error: null\n                });\n\n              case 25:\n                _context10.prev = 25;\n                _context10.t0 = _context10[\"catch\"](0);\n\n                if (!isAuthError(_context10.t0)) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context10.t0\n                });\n\n              case 29:\n                throw _context10.t0;\n\n              case 30:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 25]]);\n      }));\n    }\n    /**\r\n     * Decodes a JWT (without performing any validation).\r\n     */\n\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\r\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n     * @param currentSession The current session that minimally contains an access token and refresh token.\r\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n\n                if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 3:\n                timeNow = Date.now() / 1000;\n                expiresAt = timeNow;\n                hasExpired = true;\n                session = null;\n                payload = decodeJWTPayload(currentSession.access_token);\n\n                if (payload.exp) {\n                  expiresAt = payload.exp;\n                  hasExpired = expiresAt <= timeNow;\n                }\n\n                if (!hasExpired) {\n                  _context11.next = 22;\n                  break;\n                }\n\n                _context11.next = 12;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 12:\n                _yield$this$_callRefr2 = _context11.sent;\n                refreshedSession = _yield$this$_callRefr2.session;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 17:\n                if (refreshedSession) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                session = refreshedSession;\n                _context11.next = 32;\n                break;\n\n              case 22:\n                _context11.next = 24;\n                return this.getUser(currentSession.access_token);\n\n              case 24:\n                _yield$this$getUser = _context11.sent;\n                data = _yield$this$getUser.data;\n                _error2 = _yield$this$getUser.error;\n\n                if (!_error2) {\n                  _context11.next = 29;\n                  break;\n                }\n\n                throw _error2;\n\n              case 29:\n                session = {\n                  access_token: currentSession.access_token,\n                  refresh_token: currentSession.refresh_token,\n                  user: data.user,\n                  token_type: 'bearer',\n                  expires_in: expiresAt - timeNow,\n                  expires_at: expiresAt\n                };\n                _context11.next = 32;\n                return this._saveSession(session);\n\n              case 32:\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 35:\n                _context11.prev = 35;\n                _context11.t0 = _context11[\"catch\"](0);\n\n                if (!isAuthError(_context11.t0)) {\n                  _context11.next = 39;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context11.t0\n                });\n\n              case 39:\n                throw _context11.t0;\n\n              case 40:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 35]]);\n      }));\n    }\n    /**\r\n     * Returns a new session, regardless of expiry status.\r\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n     * If the current session's refresh token is invalid, an error will be thrown.\r\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n     */\n\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n\n                if (currentSession) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                _context12.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio3 = _context12.sent;\n                data = _yield$this$getSessio3.data;\n                _error3 = _yield$this$getSessio3.error;\n\n                if (!_error3) {\n                  _context12.next = 9;\n                  break;\n                }\n\n                throw _error3;\n\n              case 9:\n                currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n\n              case 10:\n                if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                  _context12.next = 12;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 12:\n                _context12.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 14:\n                _yield$this$_callRefr3 = _context12.sent;\n                session = _yield$this$_callRefr3.session;\n                error = _yield$this$_callRefr3.error;\n\n                if (!error) {\n                  _context12.next = 19;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 19:\n                if (session) {\n                  _context12.next = 21;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 21:\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 24:\n                _context12.prev = 24;\n                _context12.t0 = _context12[\"catch\"](0);\n\n                if (!isAuthError(_context12.t0)) {\n                  _context12.next = 28;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context12.t0\n                });\n\n              case 28:\n                throw _context12.t0;\n\n              case 29:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 24]]);\n      }));\n    }\n    /**\r\n     * Gets the session data from a URL string\r\n     */\n\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var error_description, error_code, _error4, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n\n                if (isBrowser()) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n              case 3:\n                if (this._isImplicitGrantFlow()) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n\n              case 5:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context13.next = 14;\n                  break;\n                }\n\n                error_code = getParameterByName('error_code');\n\n                if (error_code) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error_code detected.');\n\n              case 10:\n                _error4 = getParameterByName('error');\n\n                if (_error4) {\n                  _context13.next = 13;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error detected.');\n\n              case 13:\n                throw new AuthImplicitGrantRedirectError(error_description, {\n                  error: _error4,\n                  code: error_code\n                });\n\n              case 14:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No access_token detected.');\n\n              case 19:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context13.next = 22;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n\n              case 22:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context13.next = 25;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n\n              case 25:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context13.next = 28;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No token_type detected.');\n\n              case 28:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context13.next = 32;\n                return this.getUser(access_token);\n\n              case 32:\n                _yield$this$getUser2 = _context13.sent;\n                data = _yield$this$getUser2.data;\n                error = _yield$this$getUser2.error;\n\n                if (!error) {\n                  _context13.next = 37;\n                  break;\n                }\n\n                throw error;\n\n              case 37:\n                user = data.user;\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                redirectType = getParameterByName('type'); // Remove tokens from URL and popping the URL from the back stack\n\n                window.location.replace(window.location.href.split('#')[0]);\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    redirectType: redirectType\n                  },\n                  error: null\n                });\n\n              case 44:\n                _context13.prev = 44;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!isAuthError(_context13.t0)) {\n                  _context13.next = 48;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    redirectType: null\n                  },\n                  error: _context13.t0\n                });\n\n              case 48:\n                throw _context13.t0;\n\n              case 49:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 44]]);\n      }));\n    }\n    /**\r\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n     */\n\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\r\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n     *\r\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;\n\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio4 = _context14.sent;\n                data = _yield$this$getSessio4.data;\n                sessionError = _yield$this$getSessio4.error;\n\n                if (!sessionError) {\n                  _context14.next = 7;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  error: sessionError\n                });\n\n              case 7:\n                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                if (!accessToken) {\n                  _context14.next = 16;\n                  break;\n                }\n\n                _context14.next = 11;\n                return this.admin.signOut(accessToken);\n\n              case 11:\n                _yield$this$admin$sig = _context14.sent;\n                error = _yield$this$admin$sig.error;\n\n                if (!error) {\n                  _context14.next = 16;\n                  break;\n                }\n\n                if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                  _context14.next = 16;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 16:\n                _context14.next = 18;\n                return this._removeSession();\n\n              case 18:\n                this._notifyAllSubscribers('SIGNED_OUT', null);\n\n                return _context14.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 20:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\r\n     * Receive a notification every time an auth event happens.\r\n     * @param callback A callback function to be invoked when an auth event happens.\r\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n    /**\r\n     * Sends a password reset request to an email address.\r\n     * @param email The email address of the user.\r\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _context15.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                  body: {\n                    email: email,\n                    gotrue_meta_security: {\n                      captcha_token: options.captchaToken\n                    }\n                  },\n                  headers: this.headers,\n                  redirectTo: options.redirectTo\n                });\n\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 6:\n                _context15.prev = 6;\n                _context15.t0 = _context15[\"catch\"](0);\n\n                if (!isAuthError(_context15.t0)) {\n                  _context15.next = 10;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", {\n                  data: null,\n                  error: _context15.t0\n                });\n\n              case 10:\n                throw _context15.t0;\n\n              case 11:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 6]]);\n      }));\n    }\n    /**\r\n     * Generates a new JWT.\r\n     * @param refreshToken A valid refresh token that was returned on login.\r\n     */\n\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                _context16.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                  body: {\n                    refresh_token: refreshToken\n                  },\n                  headers: this.headers,\n                  xform: _sessionResponse\n                });\n\n              case 3:\n                return _context16.abrupt(\"return\", _context16.sent);\n\n              case 6:\n                _context16.prev = 6;\n                _context16.t0 = _context16[\"catch\"](0);\n\n                if (!isAuthError(_context16.t0)) {\n                  _context16.next = 10;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context16.t0\n                });\n\n              case 10:\n                throw _context16.t0;\n\n              case 11:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[0, 6]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var url = this._getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams\n      }); // try to open on the browser\n\n\n      if (isBrowser()) {\n        window.location.assign(url);\n      }\n\n      return {\n        data: {\n          provider: provider,\n          url: url\n        },\n        error: null\n      };\n    }\n    /**\r\n     * Recovers the session from LocalStorage and refreshes\r\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _this2 = this;\n\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _context17.next = 3;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                currentSession = _context17.sent;\n\n                if (this._isValidSession(currentSession)) {\n                  _context17.next = 9;\n                  break;\n                }\n\n                if (!(currentSession !== null)) {\n                  _context17.next = 8;\n                  break;\n                }\n\n                _context17.next = 8;\n                return this._removeSession();\n\n              case 8:\n                return _context17.abrupt(\"return\");\n\n              case 9:\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                  _context17.next = 32;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context17.next = 28;\n                  break;\n                }\n\n                this.networkRetries++;\n                _context17.next = 15;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 15:\n                _yield$this$_callRefr4 = _context17.sent;\n                error = _yield$this$_callRefr4.error;\n\n                if (!error) {\n                  _context17.next = 25;\n                  break;\n                }\n\n                console.log(error.message);\n\n                if (!(error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)) {\n                  _context17.next = 23;\n                  break;\n                }\n\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(function () {\n                  return _this2._recoverAndRefresh();\n                }, Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return _context17.abrupt(\"return\");\n\n              case 23:\n                _context17.next = 25;\n                return this._removeSession();\n\n              case 25:\n                this.networkRetries = 0;\n                _context17.next = 30;\n                break;\n\n              case 28:\n                _context17.next = 30;\n                return this._removeSession();\n\n              case 30:\n                _context17.next = 36;\n                break;\n\n              case 32:\n                if (!this.persistSession) {\n                  _context17.next = 35;\n                  break;\n                }\n\n                _context17.next = 35;\n                return this._saveSession(currentSession);\n\n              case 35:\n                this._notifyAllSubscribers('SIGNED_IN', currentSession);\n\n              case 36:\n                _context17.next = 42;\n                break;\n\n              case 38:\n                _context17.prev = 38;\n                _context17.t0 = _context17[\"catch\"](0);\n                console.error(_context17.t0);\n                return _context17.abrupt(\"return\");\n\n              case 42:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this, [[0, 38]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$_refreshA, data, error, result, _result;\n\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!this.refreshingDeferred) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\", this.refreshingDeferred.promise);\n\n              case 2:\n                _context18.prev = 2;\n                this.refreshingDeferred = new Deferred();\n\n                if (refreshToken) {\n                  _context18.next = 6;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 6:\n                _context18.next = 8;\n                return this._refreshAccessToken(refreshToken);\n\n              case 8:\n                _yield$this$_refreshA = _context18.sent;\n                data = _yield$this$_refreshA.data;\n                error = _yield$this$_refreshA.error;\n\n                if (!error) {\n                  _context18.next = 13;\n                  break;\n                }\n\n                throw error;\n\n              case 13:\n                if (data.session) {\n                  _context18.next = 15;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 15:\n                _context18.next = 17;\n                return this._saveSession(data.session);\n\n              case 17:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n                result = {\n                  session: data.session,\n                  error: null\n                };\n                this.refreshingDeferred.resolve(result);\n                return _context18.abrupt(\"return\", result);\n\n              case 23:\n                _context18.prev = 23;\n                _context18.t0 = _context18[\"catch\"](2);\n\n                if (!isAuthError(_context18.t0)) {\n                  _context18.next = 29;\n                  break;\n                }\n\n                _result = {\n                  session: null,\n                  error: _context18.t0\n                };\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n                return _context18.abrupt(\"return\", _result);\n\n              case 29:\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context18.t0);\n                throw _context18.t0;\n\n              case 31:\n                _context18.prev = 31;\n                this.refreshingDeferred = null;\n                return _context18.finish(31);\n\n              case 34:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\r\n     * set currentSession and currentUser\r\n     * process to _startAutoRefreshToken if possible\r\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var expiresAt, timeNow, expiresIn, refreshDurationBeforeExpires;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (!this.persistSession) {\n                  this.inMemorySession = session;\n                }\n\n                expiresAt = session.expires_at;\n\n                if (expiresAt) {\n                  timeNow = Math.round(Date.now() / 1000);\n                  expiresIn = expiresAt - timeNow;\n                  refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n                  this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n                }\n\n                if (!(this.persistSession && session.expires_at)) {\n                  _context19.next = 6;\n                  break;\n                }\n\n                _context19.next = 6;\n                return this._persistSession(session);\n\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!this.persistSession) {\n                  _context20.next = 5;\n                  break;\n                }\n\n                _context20.next = 3;\n                return removeItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                _context20.next = 6;\n                break;\n\n              case 5:\n                this.inMemorySession = null;\n\n              case 6:\n                if (this.refreshTokenTimer) {\n                  clearTimeout(this.refreshTokenTimer);\n                }\n\n              case 7:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\r\n     * Clear and re-create refresh token timer\r\n     * @param value time intervals in milliseconds.\r\n     * @param session The current session.\r\n     */\n\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this3 = this;\n\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n          var _yield$this$getSessio5, session, sessionError, _yield$this$_callRefr5, error;\n\n          return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n            while (1) {\n              switch (_context21.prev = _context21.next) {\n                case 0:\n                  this.networkRetries++;\n                  _context21.next = 3;\n                  return this.getSession();\n\n                case 3:\n                  _yield$this$getSessio5 = _context21.sent;\n                  session = _yield$this$getSessio5.data.session;\n                  sessionError = _yield$this$getSessio5.error;\n\n                  if (!(!sessionError && session)) {\n                    _context21.next = 13;\n                    break;\n                  }\n\n                  _context21.next = 9;\n                  return this._callRefreshToken(session.refresh_token);\n\n                case 9:\n                  _yield$this$_callRefr5 = _context21.sent;\n                  error = _yield$this$_callRefr5.error;\n                  if (!error) this.networkRetries = 0;\n                  if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n\n                case 13:\n                case \"end\":\n                  return _context21.stop();\n              }\n            }\n          }, _callee21, this);\n        }));\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      var _this4 = this;\n\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {\n          return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n            return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n              while (1) {\n                switch (_context22.prev = _context22.next) {\n                  case 0:\n                    if (!(document.visibilityState === 'visible')) {\n                      _context22.next = 5;\n                      break;\n                    }\n\n                    _context22.next = 3;\n                    return this.initializePromise;\n\n                  case 3:\n                    _context22.next = 5;\n                    return this._recoverAndRefresh();\n\n                  case 5:\n                  case \"end\":\n                    return _context22.stop();\n                }\n              }\n            }, _callee22, this);\n          }));\n        });\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    }\n    /**\r\n     * Generates the relevant login URL for a third-party provider.\r\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n     */\n\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      var urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.queryParams) {\n        var query = new URLSearchParams(options.queryParams);\n        urlParams.push(query.toString());\n      }\n\n      return \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&'));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var _yield$this$getSessio6, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.prev = 0;\n                _context23.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio6 = _context23.sent;\n                sessionData = _yield$this$getSessio6.data;\n                sessionError = _yield$this$getSessio6.error;\n\n                if (!sessionError) {\n                  _context23.next = 8;\n                  break;\n                }\n\n                return _context23.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context23.next = 10;\n                return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context23.abrupt(\"return\", _context23.sent);\n\n              case 13:\n                _context23.prev = 13;\n                _context23.t0 = _context23[\"catch\"](0);\n\n                if (!isAuthError(_context23.t0)) {\n                  _context23.next = 17;\n                  break;\n                }\n\n                return _context23.abrupt(\"return\", {\n                  data: null,\n                  error: _context23.t0\n                });\n\n              case 17:\n                throw _context23.t0;\n\n              case 18:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this, [[0, 13]]);\n      }));\n    }\n    /**\r\n     * Enrolls a factor\r\n     * @param friendlyName Human readable name assigned to a device\r\n     * @param factorType device which we're validating against. Can only be TOTP for now.\r\n     * @param issuer domain which the user is enrolling with\r\n     */\n\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var _yield$this$getSessio7, sessionData, sessionError, _yield$_request5, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.prev = 0;\n                _context24.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio7 = _context24.sent;\n                sessionData = _yield$this$getSessio7.data;\n                sessionError = _yield$this$getSessio7.error;\n\n                if (!sessionError) {\n                  _context24.next = 8;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context24.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                  body: {\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType,\n                    issuer: params.issuer\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request5 = _context24.sent;\n                data = _yield$_request5.data;\n                error = _yield$_request5.error;\n\n                if (!error) {\n                  _context24.next = 15;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                  data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n                }\n\n                return _context24.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 19:\n                _context24.prev = 19;\n                _context24.t0 = _context24[\"catch\"](0);\n\n                if (!isAuthError(_context24.t0)) {\n                  _context24.next = 23;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", {\n                  data: null,\n                  error: _context24.t0\n                });\n\n              case 23:\n                throw _context24.t0;\n\n              case 24:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this, [[0, 19]]);\n      }));\n    }\n    /**\r\n     * Validates a device as part of the enrollment step.\r\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n     * @param code Code Generated by an authenticator device\r\n     */\n\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var _yield$this$getSessio8, sessionData, sessionError, _yield$_request6, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.prev = 0;\n                _context25.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio8 = _context25.sent;\n                sessionData = _yield$this$getSessio8.data;\n                sessionError = _yield$this$getSessio8.error;\n\n                if (!sessionError) {\n                  _context25.next = 8;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context25.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                  body: {\n                    code: params.code,\n                    challenge_id: params.challengeId\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request6 = _context25.sent;\n                data = _yield$_request6.data;\n                error = _yield$_request6.error;\n\n                if (!error) {\n                  _context25.next = 15;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                _context25.next = 17;\n                return this._saveSession(Object.assign({\n                  expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                }, data));\n\n              case 17:\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n                return _context25.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 21:\n                _context25.prev = 21;\n                _context25.t0 = _context25[\"catch\"](0);\n\n                if (!isAuthError(_context25.t0)) {\n                  _context25.next = 25;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", {\n                  data: null,\n                  error: _context25.t0\n                });\n\n              case 25:\n                throw _context25.t0;\n\n              case 26:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this, [[0, 21]]);\n      }));\n    }\n    /**\r\n     * Creates a challenge which a user can verify against\r\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n     */\n\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var _yield$this$getSessio9, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.prev = 0;\n                _context26.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio9 = _context26.sent;\n                sessionData = _yield$this$getSessio9.data;\n                sessionError = _yield$this$getSessio9.error;\n\n                if (!sessionError) {\n                  _context26.next = 8;\n                  break;\n                }\n\n                return _context26.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context26.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context26.abrupt(\"return\", _context26.sent);\n\n              case 13:\n                _context26.prev = 13;\n                _context26.t0 = _context26[\"catch\"](0);\n\n                if (!isAuthError(_context26.t0)) {\n                  _context26.next = 17;\n                  break;\n                }\n\n                return _context26.abrupt(\"return\", {\n                  data: null,\n                  error: _context26.t0\n                });\n\n              case 17:\n                throw _context26.t0;\n\n              case 18:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this, [[0, 13]]);\n      }));\n    }\n    /**\r\n     * Creates a challenge and immediately verifies it\r\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n     * @param code Code Generated by an authenticator device\r\n     */\n\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var _yield$this$_challeng, challengeData, challengeError;\n\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this._challenge({\n                  factorId: params.factorId\n                });\n\n              case 2:\n                _yield$this$_challeng = _context27.sent;\n                challengeData = _yield$this$_challeng.data;\n                challengeError = _yield$this$_challeng.error;\n\n                if (!challengeError) {\n                  _context27.next = 7;\n                  break;\n                }\n\n                return _context27.abrupt(\"return\", {\n                  data: null,\n                  error: challengeError\n                });\n\n              case 7:\n                _context27.next = 9;\n                return this._verify({\n                  factorId: params.factorId,\n                  challengeId: challengeData.id,\n                  code: params.code\n                });\n\n              case 9:\n                return _context27.abrupt(\"return\", _context27.sent);\n\n              case 10:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\r\n     * Displays all devices for a given user\r\n     */\n\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.getUser();\n\n              case 2:\n                _yield$this$getUser3 = _context28.sent;\n                user = _yield$this$getUser3.data.user;\n                userError = _yield$this$getUser3.error;\n\n                if (!userError) {\n                  _context28.next = 7;\n                  break;\n                }\n\n                return _context28.abrupt(\"return\", {\n                  data: null,\n                  error: userError\n                });\n\n              case 7:\n                factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n                totp = factors.filter(function (factor) {\n                  return factor.factor_type === 'totp' && factor.status === 'verified';\n                });\n                return _context28.abrupt(\"return\", {\n                  data: {\n                    all: factors,\n                    totp: totp\n                  },\n                  error: null\n                });\n\n              case 10:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\r\n     * Gets the current and next authenticator assurance level (AAL)\r\n     * and the current authentication methods for the session (AMR)\r\n     */\n\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _yield$this$getSessio10, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio10 = _context29.sent;\n                session = _yield$this$getSessio10.data.session;\n                sessionError = _yield$this$getSessio10.error;\n\n                if (!sessionError) {\n                  _context29.next = 7;\n                  break;\n                }\n\n                return _context29.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 7:\n                if (session) {\n                  _context29.next = 9;\n                  break;\n                }\n\n                return _context29.abrupt(\"return\", {\n                  data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                  },\n                  error: null\n                });\n\n              case 9:\n                payload = this._decodeJWT(session.access_token);\n                currentLevel = null;\n\n                if (payload.aal) {\n                  currentLevel = payload.aal;\n                }\n\n                nextLevel = currentLevel;\n                verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                  return factor.status === 'verified';\n                })) !== null && _b !== void 0 ? _b : [];\n\n                if (verifiedFactors.length > 0) {\n                  nextLevel = 'aal2';\n                }\n\n                currentAuthenticationMethods = payload.amr || [];\n                return _context29.abrupt(\"return\", {\n                  data: {\n                    currentLevel: currentLevel,\n                    nextLevel: nextLevel,\n                    currentAuthenticationMethods: currentAuthenticationMethods\n                  },\n                  error: null\n                });\n\n              case 17:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n  }]);\n\n  return GoTrueClient;\n}();\n\nexport { GoTrueClient as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SACEC,eADF,EAEEC,aAFF,EAGEC,UAHF,EAIEC,eAJF,EAKEC,WALF,QAMO,iBANP;AAOA,SAEEC,8BAFF,EAGEC,2BAHF,EAIEC,uBAJF,EAKEC,uBALF,EAMEC,gBANF,EAOEC,cAPF,EAQEC,WARF,QASO,cATP;AAUA,SAAgBC,QAAhB,EAA0BC,gBAA1B,EAA4CC,aAA5C,EAA2DC,YAA3D,QAA+E,aAA/E;AACA,SACEC,gBADF,EAEEC,QAFF,EAGEC,YAHF,EAIEC,kBAJF,EAKEC,SALF,EAMEC,eANF,EAOEC,YAPF,EAQEC,YARF,EASEC,IATF,QAUO,eAVP;AAWA,OAAOC,mBAAP,MAAgC,qBAAhC;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AAuCAA,kBAAkB,G,CAAG;;AAErB,IAAMC,eAAe,GAA6D;EAChFC,GAAG,EAAE1B,UAD2E;EAEhF2B,UAAU,EAAEzB,WAFoE;EAGhF0B,gBAAgB,EAAE,IAH8D;EAIhFC,cAAc,EAAE,IAJgE;EAKhFC,kBAAkB,EAAE,IAL4D;EAMhFC,OAAO,EAAEjC;AANuE,CAAlF;;IASqBkC,Y;EA0CnB;;;EAGA,sBAAYC,OAAZ,EAAwC;IAAA;;IArB9B,2BAAiD,IAAIC,GAAJ,EAAjD;IAEA,sBAAiB,CAAjB;IACA,0BAA8D,IAA9D;IACV;;;;;;;IAMU,yBAAsD,IAAtD;IACA,0BAAqB,IAArB;IAWR,IAAMC,QAAQ,mCAAQV,eAAR,GAA4BQ,OAA5B,CAAd;IACA,KAAKG,eAAL,GAAuB,IAAvB;IACA,KAAKT,UAAL,GAAkBQ,QAAQ,CAACR,UAA3B;IACA,KAAKC,gBAAL,GAAwBO,QAAQ,CAACP,gBAAjC;IACA,KAAKC,cAAL,GAAsBM,QAAQ,CAACN,cAA/B;IACA,KAAKQ,OAAL,GAAeF,QAAQ,CAACE,OAAT,IAAoBd,mBAAnC;IACA,KAAKe,KAAL,GAAa,IAAIzC,cAAJ,CAAmB;MAC9B6B,GAAG,EAAES,QAAQ,CAACT,GADgB;MAE9BK,OAAO,EAAEI,QAAQ,CAACJ,OAFY;MAG9BQ,KAAK,EAAEJ,QAAQ,CAACI;IAHc,CAAnB,CAAb;IAMA,KAAKb,GAAL,GAAWS,QAAQ,CAACT,GAApB;IACA,KAAKK,OAAL,GAAeI,QAAQ,CAACJ,OAAxB;IACA,KAAKQ,KAAL,GAAanB,YAAY,CAACe,QAAQ,CAACI,KAAV,CAAzB;IACA,KAAKT,kBAAL,GAA0BK,QAAQ,CAACL,kBAAnC;IAEA,KAAKU,UAAL;IACA,KAAKC,GAAL,GAAW;MACTC,MAAM,EAAE,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CADC;MAETC,MAAM,EAAE,KAAKC,OAAL,CAAaF,IAAb,CAAkB,IAAlB,CAFC;MAGTG,QAAQ,EAAE,KAAKC,SAAL,CAAeJ,IAAf,CAAoB,IAApB,CAHD;MAITK,SAAS,EAAE,KAAKC,UAAL,CAAgBN,IAAhB,CAAqB,IAArB,CAJF;MAKTO,WAAW,EAAE,KAAKC,YAAL,CAAkBR,IAAlB,CAAuB,IAAvB,CALJ;MAMTS,kBAAkB,EAAE,KAAKC,mBAAL,CAAyBV,IAAzB,CAA8B,IAA9B,CANX;MAOTW,8BAA8B,EAAE,KAAKC,+BAAL,CAAqCZ,IAArC,CAA0C,IAA1C;IAPvB,CAAX;EASD;EAED;;;;;;;;;WAKA,sBAAU;MACR,IAAI,CAAC,KAAKa,iBAAV,EAA6B;QAC3B,KAAKA,iBAAL,GAAyB,KAAKC,WAAL,EAAzB;MACD;;MAED,OAAO,KAAKD,iBAAZ;IACD;IAED;;;;;;;;;WAMc,uBAAW;;;;;;;;qBACnB,KAAKA;;;;;iDACA,KAAKA;;;;;sBAIR,KAAK3B,kBAAL,IAA2B,KAAK6B,oBAAL;;;;;;gBACL,OAAM,KAAKC,kBAAL,EAAN;;;;gBAAhBC;gBAAMC;;qBAEVA;;;;;;gBAGF,OAAM,KAAKC,cAAL,EAAN;;;iDAEO;kBAAED,KAAK,EAALA;gBAAF;;;gBAGDE,UAA0BH,KAA1BG,SAASC,eAAiBJ,KAAjBI;;gBAEjB,OAAM,KAAKC,YAAL,CAAkBF,OAAlB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,WAA3B,EAAwCH,OAAxC;;gBACA,IAAIC,YAAY,KAAK,UAArB,EAAiC;kBAC/B,KAAKE,qBAAL,CAA2B,mBAA3B,EAAgDH,OAAhD;gBACD;;iDAEM;kBAAEF,KAAK,EAAE;gBAAT;;;;gBAIT,OAAM,KAAKM,kBAAL,EAAN;;;iDACO;kBAAEN,KAAK,EAAE;gBAAT;;;;;;qBAEHrD,WAAW;;;;;iDACN;kBAAEqD,KAAK;gBAAP;;;iDAGF;kBACLA,KAAK,EAAE,IAAIvD,gBAAJ,CAAqB,wCAArB;gBADF;;;;;gBAIP,KAAK8D,uBAAL;;;;;;;;;;;IAEH;IAED;;;;;;;;;;;;WASM,gBAAOC,WAAP,EAAiD;;;;;;;;;;;;gBAEnD,OAAM,KAAKP,cAAL,EAAN;;;sBAGI,WAAWO;;;;;gBACLC,QAA6BD,YAA7BC,OAAOC,WAAsBF,YAAtBE,UAAUvC,UAAYqC,YAAZrC;;gBACnB,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,cAA2C;kBAC7DK,OAAO,EAAE,KAAKA,OAD+C;kBAE7D0C,UAAU,EAAExC,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEyC,eAFwC;kBAG7DC,IAAI,EAAE;oBACJJ,KAAK,EAALA,KADI;oBAEJC,QAAQ,EAARA,QAFI;oBAGJX,IAAI,EAAE,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEA,IAAT,MAAa,IAAb,IAAae,aAAb,GAAaA,EAAb,GAAiB,EAHnB;oBAIJC,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE8C;oBAA1B;kBAJlB,CAHuD;kBAS7DC,KAAK,EAAErE;gBATsD,CAA3C,CAAd;;;gBAANsE;;;;;sBAWS,WAAWX;;;;;gBACZY,QAA6BZ,YAA7BY,OAAOV,YAAsBF,YAAtBE,UAAUvC,WAAYqC,YAAZrC;;gBACnB,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,cAA2C;kBAC7DK,OAAO,EAAE,KAAKA,OAD+C;kBAE7D4C,IAAI,EAAE;oBACJO,KAAK,EAALA,KADI;oBAEJV,QAAQ,EAARA,SAFI;oBAGJX,IAAI,EAAE,cAAO,SAAP,YAAO,WAAP,GAAO,MAAP,WAAO,CAAEA,IAAT,MAAa,IAAb,IAAasB,aAAb,GAAaA,EAAb,GAAiB,EAHnB;oBAIJN,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,QAAO,SAAP,YAAO,WAAP,GAAO,MAAP,WAAO,CAAE8C;oBAA1B;kBAJlB,CAFuD;kBAQ7DC,KAAK,EAAErE;gBARsD,CAA3C,CAAd;;;gBAANsE;;;;;sBAWM,IAAI7E,2BAAJ,CACJ,iEADI;;;uBAKgB6E,KAAhBpB,kBAAMC;;sBAEVA,KAAK,IAAI,CAACD;;;;;kDACL;kBAAEA,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAAEA;gBAA9C;;;gBAGHE,UAA0BH,IAAI,CAACG;gBAC/BoB,OAAoBvB,IAAI,CAACuB;;qBAE3BvB,IAAI,CAACG;;;;;;gBACP,OAAM,KAAKE,YAAL,CAAkBL,IAAI,CAACG,OAAvB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,WAA3B,EAAwCH,OAAxC;;;kDAGK;kBAAEH,IAAI,EAAE;oBAAEuB,IAAI,EAAJA,IAAF;oBAAQpB,OAAO,EAAPA;kBAAR,CAAR;kBAA2BF,KAAK,EAAE;gBAAlC;;;;;;qBAEHrD,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK;gBAA5C;;;;;;;;;;;;IAKZ;IAED;;;;;;;;;;;WAQM,4BAAmBQ,WAAnB,EAA6D;;;;;;;;;;;;gBAE/D,OAAM,KAAKP,cAAL,EAAN;;;sBAGI,WAAWO;;;;;gBACLC,QAA6BD,YAA7BC,OAAOC,WAAsBF,YAAtBE,UAAUvC,UAAYqC,YAAZrC;;gBACnB,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,iCAA8D;kBAChFK,OAAO,EAAE,KAAKA,OADkE;kBAEhF4C,IAAI,EAAE;oBACJJ,KAAK,EAALA,KADI;oBAEJC,QAAQ,EAARA,QAFI;oBAGJX,IAAI,EAAE,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEA,IAAT,MAAa,IAAb,IAAae,aAAb,GAAaA,EAAb,GAAiB,EAHnB;oBAIJC,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE8C;oBAA1B;kBAJlB,CAF0E;kBAQhFC,KAAK,EAAErE;gBARyE,CAA9D,CAAd;;;gBAANsE;;;;;sBAUS,WAAWX;;;;;gBACZY,QAA6BZ,YAA7BY,OAAOV,aAAsBF,YAAtBE,UAAUvC,YAAYqC,YAAZrC;;gBACnB,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,iCAA8D;kBAChFK,OAAO,EAAE,KAAKA,OADkE;kBAEhF4C,IAAI,EAAE;oBACJO,KAAK,EAALA,KADI;oBAEJV,QAAQ,EAARA,UAFI;oBAGJX,IAAI,EAAE,eAAO,SAAP,aAAO,WAAP,GAAO,MAAP,YAAO,CAAEA,IAAT,MAAa,IAAb,IAAasB,aAAb,GAAaA,EAAb,GAAiB,EAHnB;oBAIJN,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,SAAO,SAAP,aAAO,WAAP,GAAO,MAAP,YAAO,CAAE8C;oBAA1B;kBAJlB,CAF0E;kBAQhFC,KAAK,EAAErE;gBARyE,CAA9D,CAAd;;;gBAANsE;;;;;sBAWM,IAAI7E,2BAAJ,CACJ,iEADI;;;wBAIgB6E,KAAhBpB,mBAAMC;;sBACVA,KAAK,IAAI,CAACD;;;;;kDAAa;kBAAEA,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAALA;gBAAvC;;;qBACvBD,IAAI,CAACG;;;;;;gBACP,OAAM,KAAKE,YAAL,CAAkBL,IAAI,CAACG,OAAvB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,WAA3B,EAAwCN,IAAI,CAACG,OAA7C;;;kDAEK;kBAAEH,IAAI,EAAJA,IAAF;kBAAQC,KAAK,EAALA;gBAAR;;;;;;qBAEHrD,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK;gBAA5C;;;;;;;;;;;;IAIZ;IAED;;;;;;WAGM,yBAAgBQ,WAAhB,EAAuD;;;;;;;;;gBAC3D,OAAM,KAAKP,cAAL,EAAN;;;kDACO,KAAKsB,qBAAL,CAA2Bf,WAAW,CAACgB,QAAvC,EAAiD;kBACtDb,UAAU,EAAE,iBAAW,CAACxC,OAAZ,MAAmB,IAAnB,IAAmB2C,aAAnB,GAAmB,MAAnB,GAAmBA,GAAEH,UADqB;kBAEtDc,MAAM,EAAE,iBAAW,CAACtD,OAAZ,MAAmB,IAAnB,IAAmBkD,aAAnB,GAAmB,MAAnB,GAAmBA,GAAEI,MAFyB;kBAGtDC,WAAW,EAAE,iBAAW,CAACvD,OAAZ,MAAmB,IAAnB,IAAmBwD,aAAnB,GAAmB,MAAnB,GAAmBA,GAAED;gBAHoB,CAAjD;;;;;;;;;IAKR;IAED;;;;;;;;;;;;;;WAWM,uBAAclB,WAAd,EAA4D;;;;;;;;;;;;gBAE9D,OAAM,KAAKP,cAAL,EAAN;;;sBAEI,WAAWO;;;;;gBACLC,QAAmBD,YAAnBC,OAAOtC,UAAYqC,YAAZrC;;gBACG,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,WAAwC;kBACtEK,OAAO,EAAE,KAAKA,OADwD;kBAEtE4C,IAAI,EAAE;oBACJJ,KAAK,EAALA,KADI;oBAEJV,IAAI,EAAE,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEA,IAAT,MAAa,IAAb,IAAae,aAAb,GAAaA,EAAb,GAAiB,EAFnB;oBAGJc,WAAW,EAAE,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,gBAAT,MAAyB,IAAzB,IAAyBR,aAAzB,GAAyBA,EAAzB,GAA6B,IAHtC;oBAIJN,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE8C;oBAA1B;kBAJlB,CAFgE;kBAQtEN,UAAU,EAAExC,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEyC;gBARiD,CAAxC,CAAd;;;;gBAAVZ;kDAUD;kBAAED,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAALA;gBAAvC;;;sBAEL,WAAWQ;;;;;gBACLY,QAAmBZ,YAAnBY,OAAOjD,YAAYqC,YAAZrC;;gBACG,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,WAAwC;kBACtEK,OAAO,EAAE,KAAKA,OADwD;kBAEtE4C,IAAI,EAAE;oBACJO,KAAK,EAALA,KADI;oBAEJrB,IAAI,EAAE,eAAO,SAAP,aAAO,WAAP,GAAO,MAAP,YAAO,CAAEA,IAAT,MAAa,IAAb,IAAa4B,aAAb,GAAaA,EAAb,GAAiB,EAFnB;oBAGJC,WAAW,EAAE,eAAO,SAAP,aAAO,WAAP,GAAO,MAAP,YAAO,CAAEC,gBAAT,MAAyB,IAAzB,IAAyBC,aAAzB,GAAyBA,EAAzB,GAA6B,IAHtC;oBAIJf,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,SAAO,SAAP,aAAO,WAAP,GAAO,MAAP,YAAO,CAAE8C;oBAA1B;kBAJlB;gBAFgE,CAAxC,CAAd;;;;gBAAVjB;kDASD;kBAAED,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAALA;gBAAvC;;;sBAEH,IAAI1D,2BAAJ,CAAgC,mDAAhC;;;;;;qBAEFK,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK;gBAA5C;;;;;;;;;;;;IAKZ;IAED;;;;;;WAGM,mBAAU+B,MAAV,EAAiC;;;;;;;;;;;;gBAEnC,OAAM,KAAK9B,cAAL,EAAN;;;;gBAEwB,OAAMrD,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,cAA2C;kBAC/EK,OAAO,EAAE,KAAKA,OADiE;kBAE/E4C,IAAI,kCACCkB,MADD,GACO;oBACThB,oBAAoB,EAAE;sBAAEC,aAAa,EAAE,YAAM,CAAC7C,OAAP,MAAc,IAAd,IAAc2C,aAAd,GAAc,MAAd,GAAcA,GAAEG;oBAAjC;kBADb,CADP,CAF2E;kBAM/EN,UAAU,EAAE,YAAM,CAACxC,OAAP,MAAc,IAAd,IAAckD,aAAd,GAAc,MAAd,GAAcA,GAAEV,UANmD;kBAO/EO,KAAK,EAAErE;gBAPwE,CAA3C,CAAd;;;;gBAAhBkD;gBAAMC;;qBAUVA;;;;;sBACIA;;;oBAGHD;;;;;sBACG;;;gBAGFG,UAA0BH,IAAI,CAACG;gBAC/BoB,OAAavB,IAAI,CAACuB;;sBAEpBpB,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE8B;;;;;;gBACX,OAAM,KAAK5B,YAAL,CAAkBF,OAAlB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,WAA3B,EAAwCH,OAAxC;;;kDAGK;kBAAEH,IAAI,EAAE;oBAAEuB,IAAI,EAAJA,IAAF;oBAAQpB,OAAO,EAAPA;kBAAR,CAAR;kBAA2BF,KAAK,EAAE;gBAAlC;;;;;;qBAEHrD,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK;gBAA5C;;;;;;;;;;;;IAKZ;IAED;;;;;;;;;;;;;;;;;;;;;;WAmBM,uBAAc+B,MAAd,EAAmC;;;;;;;;;;gBAErC,OAAM,KAAK9B,cAAL,EAAN;;;;gBAEO,OAAMrD,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,WAAwC;kBAC3DiD,IAAI,4EACE,gBAAgBkB,MAAhB,GAAyB;oBAAEE,WAAW,EAAEF,MAAM,CAACG;kBAAtB,CAAzB,GAA8D,IADhE,GAEE,YAAYH,MAAZ,GAAqB;oBAAEI,MAAM,EAAEJ,MAAM,CAACI;kBAAjB,CAArB,GAAiD,IAFnD,GAEwD;oBAC1DC,WAAW,EAAE,kBAAM,CAACjE,OAAP,MAAc,IAAd,IAAc2C,aAAd,GAAc,MAAd,GAAcA,GAAEH,UAAhB,MAA0B,IAA1B,IAA0BU,aAA1B,GAA0BA,EAA1B,GAA8BgB;kBADe,CAFxD,GAIE,aAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAElE,OAAR,MAAe,IAAf,IAAewD,aAAf,GAAe,MAAf,GAAeA,GAAEV,YAAjB,IACA;oBAAEF,oBAAoB,EAAE;sBAAEC,aAAa,EAAEe,MAAM,CAAC5D,OAAP,CAAe8C;oBAAhC;kBAAxB,CADA,GAEA,IANF,GAMO;oBACTqB,kBAAkB,EAAE;kBADX,CANP,CADuD;kBAU3DrE,OAAO,EAAE,KAAKA,OAV6C;kBAW3DiD,KAAK,EAAEnE;gBAXoD,CAAxC,CAAd;;;;;;;;;qBAcHJ,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAIZ;IAED;;;;;;;WAIM,sBAAU;;;;;;;;;gBAsBd,OAAM,KAAKL,iBAAX;;;gBAEI4C,iBAAiC;;qBAEjC,KAAKxE;;;;;;gBACc,OAAMb,YAAY,CAAC,KAAKqB,OAAN,EAAe,KAAKV,UAApB,CAAlB;;;gBAAf2E;;sBAEFA,YAAY,KAAK;;;;;qBACf,KAAKC,eAAL,CAAqBD,YAArB;;;;;gBACFD,cAAc,GAAGC,YAAjB;;;;;;gBAEA,OAAM,KAAKvC,cAAL,EAAN;;;;;;;gBAIJsC,cAAc,GAAG,KAAKjE,eAAtB;;;oBAGGiE;;;;;kDACI;kBAAExC,IAAI,EAAE;oBAAEG,OAAO,EAAE;kBAAX,CAAR;kBAA2BF,KAAK,EAAE;gBAAlC;;;gBAGH0C,aAAaH,cAAc,CAACI,UAAf,GACfJ,cAAc,CAACI,UAAf,IAA6BC,IAAI,CAACC,GAAL,KAAa,IAD3B,GAEf;;oBACCH;;;;;kDACI;kBAAE3C,IAAI,EAAE;oBAAEG,OAAO,EAAEqC;kBAAX,CAAR;kBAAqCvC,KAAK,EAAE;gBAA5C;;;;gBAGkB,OAAM,KAAK8C,iBAAL,CAAuBP,cAAc,CAACQ,aAAtC,CAAN;;;;gBAAnB7C;gBAASF;;qBACbA;;;;;kDACK;kBAAED,IAAI,EAAE;oBAAEG,OAAO,EAAE;kBAAX,CAAR;kBAA2BF,KAAK,EAALA;gBAA3B;;;kDAGF;kBAAED,IAAI,EAAE;oBAAEG,OAAO,EAAPA;kBAAF,CAAR;kBAAqBF,KAAK,EAAE;gBAA5B;;;;;;;;;IACR;IAED;;;;;;;WAIM,iBAAQgD,GAAR,EAAoB;;;;;;;;;;;;oBAEjBA;;;;;;gBACqB,OAAM,KAAKC,UAAL,EAAN;;;;gBAAhBlD;gBAAMC;;qBACVA;;;;;sBACIA;;;gBAGR;gBACAgD,GAAG,GAAG,gBAAI,CAAC9C,OAAL,MAAY,IAAZ,IAAYY,aAAZ,GAAY,MAAZ,GAAYA,GAAEkB,YAAd,MAA0B,IAA1B,IAA0BX,aAA1B,GAA0BA,EAA1B,GAA8BgB,SAApC;;;;gBAGK,OAAMzF,QAAQ,CAAC,KAAK6B,KAAN,EAAa,KAAb,YAAuB,KAAKb,GAA5B,YAAwC;kBAC3DK,OAAO,EAAE,KAAKA,OAD6C;kBAE3D+E,GAAG,EAAEA,GAFsD;kBAG3D9B,KAAK,EAAEpE;gBAHoD,CAAxC,CAAd;;;;;;;;;qBAMHH,WAAW;;;;;kDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE;kBAAR,CAAR;kBAAwBtB,KAAK;gBAA7B;;;;;;;;;;;;IAKZ;IAED;;;;;;WAGM,oBAAWkD,UAAX,EAAqC;;;;;;;;;;gBAEY,OAAM,KAAKD,UAAL,EAAN;;;;gBAArCE,qCAANpD;gBAA0BqD,sCAAPpD;;qBACvBoD;;;;;sBACIA;;;oBAEHD,WAAW,CAACjD;;;;;sBACT,IAAI1D,uBAAJ;;;gBAEF0D,UAAmBiD,WAAW,CAACjD;;gBACF,OAAMtD,QAAQ,CAAC,KAAK6B,KAAN,EAAa,KAAb,YAAuB,KAAKb,GAA5B,YAAwC;kBACvFK,OAAO,EAAE,KAAKA,OADyE;kBAEvF4C,IAAI,EAAEqC,UAFiF;kBAGvFF,GAAG,EAAE9C,OAAO,CAAC8B,YAH0E;kBAIvFd,KAAK,EAAEpE;gBAJgF,CAAxC,CAAd;;;;gBAA3BiD;gBAAasD,6BAAPrD;;qBAMVqD;;;;;sBAAiBA;;;gBACrBnD,OAAO,CAACoB,IAAR,GAAevB,IAAI,CAACuB,IAApB;;gBACA,OAAM,KAAKlB,YAAL,CAAkBF,OAAlB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,cAA3B,EAA2CH,OAA3C;;mDAEO;kBAAEH,IAAI,EAAE;oBAAEuB,IAAI,EAAEpB,OAAO,CAACoB;kBAAhB,CAAR;kBAAgCtB,KAAK,EAAE;gBAAvC;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE;kBAAR,CAAR;kBAAwBtB,KAAK;gBAA7B;;;;;;;;;;;;IAKZ;IAED;;;;;;WAGQ,oBAAWgD,GAAX,EAAsB;MAK5B,OAAOhG,gBAAgB,CAACgG,GAAD,CAAvB;IACD;IAED;;;;;;;;WAKM,oBAAWT,cAAX,EAGL;;;;;;;;;;sBAEO,CAACA,cAAc,CAACP,YAAhB,IAAgC,CAACO,cAAc,CAACQ;;;;;sBAC5C,IAAIvG,uBAAJ;;;gBAGF8G,UAAUV,IAAI,CAACC,GAAL,KAAa;gBACzBU,YAAYD;gBACZZ,aAAa;gBACbxC,UAA0B;gBACxBsD,UAAUxG,gBAAgB,CAACuF,cAAc,CAACP,YAAhB;;gBAChC,IAAIwB,OAAO,CAACC,GAAZ,EAAiB;kBACfF,SAAS,GAAGC,OAAO,CAACC,GAApB;kBACAf,UAAU,GAAGa,SAAS,IAAID,OAA1B;gBACD;;qBAEGZ;;;;;;gBAC2C,OAAM,KAAKI,iBAAL,CACjDP,cAAc,CAACQ,aADkC,CAAN;;;;gBAA5BW,0CAATxD;gBAA2BF;;qBAG/BA;;;;;mDACK;kBAAED,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAAEA;gBAA9C;;;oBAGJ0D;;;;;mDACI;kBAAE3D,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAAE;gBAA9C;;;gBAETE,OAAO,GAAGwD,gBAAV;;;;;;gBAEwB,OAAM,KAAKC,OAAL,CAAapB,cAAc,CAACP,YAA5B,CAAN;;;;gBAAhBjC;gBAAMC;;qBACVA;;;;;sBACIA;;;gBAERE,OAAO,GAAG;kBACR8B,YAAY,EAAEO,cAAc,CAACP,YADrB;kBAERe,aAAa,EAAER,cAAc,CAACQ,aAFtB;kBAGRzB,IAAI,EAAEvB,IAAI,CAACuB,IAHH;kBAIRsC,UAAU,EAAE,QAJJ;kBAKRC,UAAU,EAAEN,SAAS,GAAGD,OALhB;kBAMRX,UAAU,EAAEY;gBANJ,CAAV;;gBAQA,OAAM,KAAKnD,YAAL,CAAkBF,OAAlB,CAAN;;;mDAGK;kBAAEH,IAAI,EAAE;oBAAEuB,IAAI,EAAEpB,OAAO,CAACoB,IAAhB;oBAAsBpB,OAAO,EAAPA;kBAAtB,CAAR;kBAAyCF,KAAK,EAAE;gBAAhD;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE;oBAAEG,OAAO,EAAE,IAAX;oBAAiBoB,IAAI,EAAE;kBAAvB,CAAR;kBAAuCtB,KAAK;gBAA5C;;;;;;;;;;;;IAKZ;IAED;;;;;;;;;WAMM,wBAAeuC,cAAf,EAAyD;;;;;;;;;;;;oBAEtDA;;;;;;gBACqB,OAAM,KAAKU,UAAL,EAAN;;;;gBAAhBlD;gBAAMC;;qBACVA;;;;;sBACIA;;;gBAGRuC,cAAc,GAAG,UAAI,CAACrC,OAAL,MAAY,IAAZ,IAAYY,aAAZ,GAAYA,EAAZ,GAAgBuB,SAAjC;;;oBAGGE,cAAc,SAAd,kBAAc,WAAd,GAAc,MAAd,iBAAc,CAAEQ;;;;;sBACb,IAAIvG,uBAAJ;;;;gBAGmB,OAAM,KAAKsG,iBAAL,CAAuBP,cAAc,CAACQ,aAAtC,CAAN;;;;gBAAnB7C;gBAASF;;qBACbA;;;;;mDACK;kBAAED,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAAEA;gBAA9C;;;oBAGJE;;;;;mDACI;kBAAEH,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK,EAAE;gBAA9C;;;mDAGF;kBAAED,IAAI,EAAE;oBAAEuB,IAAI,EAAEpB,OAAO,CAACoB,IAAhB;oBAAsBpB,OAAO,EAAPA;kBAAtB,CAAR;kBAAyCF,KAAK,EAAE;gBAAhD;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE;oBAAEuB,IAAI,EAAE,IAAR;oBAAcpB,OAAO,EAAE;kBAAvB,CAAR;kBAAuCF,KAAK;gBAA5C;;;;;;;;;;;;IAKZ;IAED;;;;;;WAGc,8BAAkB;;;;;;;;;;oBAQvB5C,SAAS;;;;;sBAAU,IAAIf,8BAAJ,CAAmC,sBAAnC;;;oBACnB,KAAKwD,oBAAL;;;;;sBACG,IAAIxD,8BAAJ,CAAmC,sCAAnC;;;gBAGFyH,oBAAoB3G,kBAAkB,CAAC,mBAAD;;qBACxC2G;;;;;gBACIC,aAAa5G,kBAAkB,CAAC,YAAD;;oBAChC4G;;;;;sBAAkB,IAAI1H,8BAAJ,CAAmC,yBAAnC;;;gBACjB2D,UAAQ7C,kBAAkB,CAAC,OAAD;;oBAC3B6C;;;;;sBAAa,IAAI3D,8BAAJ,CAAmC,oBAAnC;;;sBAEZ,IAAIA,8BAAJ,CAAmCyH,iBAAnC,EAAsD;kBAAE9D,KAAK,EAALA,OAAF;kBAASgE,IAAI,EAAED;gBAAf,CAAtD;;;gBAGFE,iBAAiB9G,kBAAkB,CAAC,gBAAD;gBACnC+G,yBAAyB/G,kBAAkB,CAAC,wBAAD;gBAC3C6E,eAAe7E,kBAAkB,CAAC,cAAD;;oBAClC6E;;;;;sBAAoB,IAAI3F,8BAAJ,CAAmC,2BAAnC;;;gBACnBwH,aAAa1G,kBAAkB,CAAC,YAAD;;oBAChC0G;;;;;sBAAkB,IAAIxH,8BAAJ,CAAmC,yBAAnC;;;gBACjB0G,gBAAgB5F,kBAAkB,CAAC,eAAD;;oBACnC4F;;;;;sBAAqB,IAAI1G,8BAAJ,CAAmC,4BAAnC;;;gBACpBuH,aAAazG,kBAAkB,CAAC,YAAD;;oBAChCyG;;;;;sBAAkB,IAAIvH,8BAAJ,CAAmC,yBAAnC;;;gBAEjBiH,UAAUa,IAAI,CAACC,KAAL,CAAWxB,IAAI,CAACC,GAAL,KAAa,IAAxB;gBACVF,aAAaW,OAAO,GAAGe,QAAQ,CAACR,UAAD;;gBAEb,OAAM,KAAKF,OAAL,CAAa3B,YAAb,CAAN;;;;gBAAhBjC;gBAAMC;;qBACVA;;;;;sBAAaA;;;gBACXsB,OAAavB,IAAI,CAACuB;gBAClBpB,UAAmB;kBACvB+D,cAAc,EAAdA,cADuB;kBAEvBC,sBAAsB,EAAtBA,sBAFuB;kBAGvBlC,YAAY,EAAZA,YAHuB;kBAIvB6B,UAAU,EAAEQ,QAAQ,CAACR,UAAD,CAJG;kBAKvBlB,UAAU,EAAVA,UALuB;kBAMvBI,aAAa,EAAbA,aANuB;kBAOvBa,UAAU,EAAVA,UAPuB;kBAQvBtC,IAAI,EAAJA;gBARuB;gBAUnBnB,eAAehD,kBAAkB,CAAC,MAAD,GAEvC;;gBACAmH,MAAM,CAACC,QAAP,CAAgBC,OAAhB,CAAwBF,MAAM,CAACC,QAAP,CAAgBE,IAAhB,CAAqBC,KAArB,CAA2B,GAA3B,EAAgC,CAAhC,CAAxB;mDAEO;kBAAE3E,IAAI,EAAE;oBAAEG,OAAO,EAAPA,OAAF;oBAAWC,YAAY,EAAZA;kBAAX,CAAR;kBAAmCH,KAAK,EAAE;gBAA1C;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE;oBAAEG,OAAO,EAAE,IAAX;oBAAiBC,YAAY,EAAE;kBAA/B,CAAR;kBAA+CH,KAAK;gBAApD;;;;;;;;;;;;IAKZ;IAED;;;;;;WAGQ,gCAAoB;MAC1B,OACE5C,SAAS,OACRuH,OAAO,CAACxH,kBAAkB,CAAC,cAAD,CAAnB,CAAP,IACCwH,OAAO,CAACxH,kBAAkB,CAAC,mBAAD,CAAnB,CAFA,CADX;IAKD;IAED;;;;;;;;;;WAOM,mBAAO;;;;;;;;;;;gBAC2B,OAAM,KAAK8F,UAAL,EAAN;;;;gBAA9BlD;gBAAaqD,sCAAPpD;;qBACVoD;;;;;mDACK;kBAAEpD,KAAK,EAAEoD;gBAAT;;;gBAEHwB,cAAc,UAAI,CAAC1E,OAAL,MAAY,IAAZ,IAAYY,aAAZ,GAAY,MAAZ,GAAYA,GAAEkB;;qBAC9B4C;;;;;;gBACgB,OAAM,KAAKpG,KAAL,CAAWqG,OAAX,CAAmBD,WAAnB,CAAN;;;;gBAAV5E;;qBACJA;;;;;oBAGItD,cAAc,CAACsD,KAAD,CAAd,KAA0BA,KAAK,CAAC8E,MAAN,KAAiB,GAAjB,IAAwB9E,KAAK,CAAC8E,MAAN,KAAiB,GAAnE;;;;;mDACG;kBAAE9E,KAAK,EAALA;gBAAF;;;;gBAIb,OAAM,KAAKC,cAAL,EAAN;;;gBACA,KAAKI,qBAAL,CAA2B,YAA3B,EAAyC,IAAzC;;mDACO;kBAAEL,KAAK,EAAE;gBAAT;;;;;;;;;IACR;IAED;;;;;;;WAIA,2BAAkB+E,QAAlB,EAAqF;MAAA;;MAGnF,IAAMC,EAAE,GAAWxH,IAAI,EAAvB;MACA,IAAMyH,YAAY,GAAiB;QACjCD,EAAE,EAAFA,EADiC;QAEjCD,QAAQ,EAARA,QAFiC;QAGjCG,WAAW,EAAE,uBAAK;UAChB,KAAI,CAACC,mBAAL,CAAyBC,MAAzB,CAAgCJ,EAAhC;QACD;MALgC,CAAnC;MAQA,KAAKG,mBAAL,CAAyBE,GAAzB,CAA6BL,EAA7B,EAAiCC,YAAjC;MAEA,OAAO;QAAElF,IAAI,EAAE;UAAEkF,YAAY,EAAZA;QAAF;MAAR,CAAP;IACD;IAED;;;;;;;;;WAMM,+BACJxE,KADI,EAKE;MAAA,IAHNtC,OAGM,uEAAF,EAAE;;;;;;;;gBASG,OAAMvB,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,eAA4C;kBAC/DiD,IAAI,EAAE;oBAAEJ,KAAK,EAALA,KAAF;oBAASM,oBAAoB,EAAE;sBAAEC,aAAa,EAAE7C,OAAO,CAAC8C;oBAAzB;kBAA/B,CADyD;kBAE/DhD,OAAO,EAAE,KAAKA,OAFiD;kBAG/D0C,UAAU,EAAExC,OAAO,CAACwC;gBAH2C,CAA5C,CAAd;;;;;;;;;qBAMHhE,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAKZ;IAED;;;;;;;WAIc,6BAAoBsF,YAApB,EAAwC;;;;;;;;gBAE3C,OAAM1I,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,sCAAmE;kBACtFiD,IAAI,EAAE;oBAAEkC,aAAa,EAAEuC;kBAAjB,CADgF;kBAEtFrH,OAAO,EAAE,KAAKA,OAFwE;kBAGtFiD,KAAK,EAAErE;gBAH+E,CAAnE,CAAd;;;;;;;;;qBAMHF,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE;oBAAEG,OAAO,EAAE,IAAX;oBAAiBoB,IAAI,EAAE;kBAAvB,CAAR;kBAAuCtB,KAAK;gBAA5C;;;;;;;;;;;;IAIZ;;;WAEO,yBAAgBwC,YAAhB,EAAqC;MAC3C,IAAM+C,cAAc,GAClB,OAAO/C,YAAP,KAAwB,QAAxB,IACAA,YAAY,KAAK,IADjB,IAEA,kBAAkBA,YAFlB,IAGA,mBAAmBA,YAHnB,IAIA,gBAAgBA,YALlB;MAOA,OAAO+C,cAAP;IACD;;;WAEO,+BACN/D,QADM,EAMA;MAAA,IAJNrD,OAIM,uEAAF,EAAE;;MAEN,IAAMP,GAAG,GAAW,KAAK4H,kBAAL,CAAwBhE,QAAxB,EAAkC;QACpDb,UAAU,EAAExC,OAAO,CAACwC,UADgC;QAEpDc,MAAM,EAAEtD,OAAO,CAACsD,MAFoC;QAGpDC,WAAW,EAAEvD,OAAO,CAACuD;MAH+B,CAAlC,CAApB,CAFM,CAON;;;MACA,IAAItE,SAAS,EAAb,EAAiB;QACfkH,MAAM,CAACC,QAAP,CAAgBkB,MAAhB,CAAuB7H,GAAvB;MACD;;MACD,OAAO;QAAEmC,IAAI,EAAE;UAAEyB,QAAQ,EAARA,QAAF;UAAY5D,GAAG,EAAHA;QAAZ,CAAR;QAA2BoC,KAAK,EAAE;MAAlC,CAAP;IACD;IAED;;;;;;;WAIc,8BAAkB;;;;;;;;;;;;;;gBAEL,OAAM9C,YAAY,CAAC,KAAKqB,OAAN,EAAe,KAAKV,UAApB,CAAlB;;;gBAAjB0E;;oBACD,KAAKE,eAAL,CAAqBF,cAArB;;;;;sBACCA,cAAc,KAAK;;;;;;gBACrB,OAAM,KAAKtC,cAAL,EAAN;;;;;;gBAMEqD,UAAUa,IAAI,CAACC,KAAL,CAAWxB,IAAI,CAACC,GAAL,KAAa,IAAxB;;sBAEZ,CAAC,oBAAc,CAACF,UAAf,MAAyB,IAAzB,IAAyB7B,aAAzB,GAAyBA,EAAzB,GAA6B4E,QAA9B,IAA0CpC,OAAO,GAAGrH;;;;;sBAClD,KAAK6B,gBAAL,IAAyByE,cAAc,CAACQ;;;;;gBAC1C,KAAK4C,cAAL;;gBACkB,OAAM,KAAK7C,iBAAL,CAAuBP,cAAc,CAACQ,aAAtC,CAAN;;;;gBAAV/C;;qBACJA;;;;;gBACF4F,OAAO,CAACC,GAAR,CAAY7F,KAAK,CAAC8F,OAAlB;;sBAEE9F,KAAK,YAAYzD,uBAAjB,IACA,KAAKoJ,cAAL,GAAsBxJ,eAAe,CAAC4J;;;;;gBAEtC,IAAI,KAAKC,iBAAT,EAA4BC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;gBAC5B,KAAKA,iBAAL,GAAyBE,UAAU,CACjC;kBAAA,OAAM,MAAI,CAAC5F,kBAAL,EAAN;gBAAA,CADiC,EAEjC6D,wBAAe,CAACgC,cAAhB,EAAkC,KAAKR,cAAvC,IAAwD,GAFvB,CAE2B;gBAF3B,CAAnC;;;;;gBAMF,OAAM,KAAK1F,cAAL,EAAN;;;gBAEF,KAAK0F,cAAL,GAAsB,CAAtB;;;;;;gBAEA,OAAM,KAAK1F,cAAL,EAAN;;;;;;;qBAGE,KAAKlC;;;;;;gBACP,OAAM,KAAKqC,YAAL,CAAkBmC,cAAlB,CAAN;;;gBAEF,KAAKlC,qBAAL,CAA2B,WAA3B,EAAwCkC,cAAxC;;;;;;;;;gBAGFqD,OAAO,CAAC5F,KAAR;;;;;;;;;;IAGH;;;WAEa,2BAAkBsF,YAAlB,EAAsC;;;;;;;;;;qBAE9C,KAAKc;;;;;mDACA,KAAKA,kBAAL,CAAwBC;;;;gBAI/B,KAAKD,kBAAL,GAA0B,IAAInJ,QAAJ,EAA1B;;oBAEKqI;;;;;sBACG,IAAI9I,uBAAJ;;;;gBAEgB,OAAM,KAAK8J,mBAAL,CAAyBhB,YAAzB,CAAN;;;;gBAAhBvF;gBAAMC;;qBACVA;;;;;sBAAaA;;;oBACZD,IAAI,CAACG;;;;;sBAAe,IAAI1D,uBAAJ;;;;gBAEzB,OAAM,KAAK4D,YAAL,CAAkBL,IAAI,CAACG,OAAvB,CAAN;;;gBACA,KAAKG,qBAAL,CAA2B,iBAA3B,EAA8CN,IAAI,CAACG,OAAnD;;gBAEMqG,SAAS;kBAAErG,OAAO,EAAEH,IAAI,CAACG,OAAhB;kBAAyBF,KAAK,EAAE;gBAAhC;gBAEf,KAAKoG,kBAAL,CAAwBI,OAAxB,CAAgCD,MAAhC;mDAEOA;;;;;;qBAEH5J,WAAW;;;;;gBACP4J,UAAS;kBAAErG,OAAO,EAAE,IAAX;kBAAiBF,KAAK;gBAAtB;gBAEf,WAAKoG,kBAAL,MAAuB,IAAvB,IAAuBtF,aAAvB,GAAuB,MAAvB,GAAuBA,GAAE0F,OAAF,CAAUD,OAAV,CAAvB;mDAEOA;;;gBAGT,WAAKH,kBAAL,MAAuB,IAAvB,IAAuB/E,aAAvB,GAAuB,MAAvB,GAAuBA,GAAEoF,MAAF,eAAvB;;;;;gBAGA,KAAKL,kBAAL,GAA0B,IAA1B;;;;;;;;;;IAEH;;;WAEO,+BAAsBM,KAAtB,EAA8CxG,OAA9C,EAAqE;MAC3E,KAAKiF,mBAAL,CAAyBwB,OAAzB,CAAiC,UAACC,CAAD;QAAA,OAAOA,CAAC,CAAC7B,QAAF,CAAW2B,KAAX,EAAkBxG,OAAlB,CAAP;MAAA,CAAjC;IACD;IAED;;;;;;;WAIc,sBAAaA,OAAb,EAA6B;;;;;;;gBACzC,IAAI,CAAC,KAAKnC,cAAV,EAA0B;kBACxB,KAAKO,eAAL,GAAuB4B,OAAvB;gBACD;;gBAEKqD,YAAYrD,OAAO,CAACyC;;gBAC1B,IAAIY,SAAJ,EAAe;kBACPD,OADO,GACGa,IAAI,CAACC,KAAL,CAAWxB,IAAI,CAACC,GAAL,KAAa,IAAxB,CADH;kBAEPgE,SAFO,GAEKtD,SAAS,GAAGD,OAFjB;kBAGPwD,4BAHO,GAGwBD,SAAS,GAAG5K,aAAZ,GAA4BA,aAA5B,GAA4C,GAHpE;;kBAIb,KAAK8K,sBAAL,CAA4B,CAACF,SAAS,GAAGC,4BAAb,IAA6C,IAAzE;gBACD;;sBAEG,KAAK/I,cAAL,IAAuBmC,OAAO,CAACyC;;;;;;gBACjC,OAAM,KAAKqE,eAAL,CAAqB9G,OAArB,CAAN;;;;;;;;;IAEH;;;WAEO,yBAAgBqC,cAAhB,EAAuC;MAC7C,OAAOhF,YAAY,CAAC,KAAKgB,OAAN,EAAe,KAAKV,UAApB,EAAgC0E,cAAhC,CAAnB;IACD;;;WAEa,0BAAc;;;;;;qBACtB,KAAKxE;;;;;;gBACP,OAAMV,eAAe,CAAC,KAAKkB,OAAN,EAAe,KAAKV,UAApB,CAArB;;;;;;;gBAEA,KAAKS,eAAL,GAAuB,IAAvB;;;gBAGF,IAAI,KAAK0H,iBAAT,EAA4B;kBAC1BC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;gBACD;;;;;;;;;IACF;IAED;;;;;;;;WAKQ,gCAAuBiB,KAAvB,EAAoC;MAAA;;MAC1C,IAAI,KAAKjB,iBAAT,EAA4BC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;MAC5B,IAAIiB,KAAK,IAAI,CAAT,IAAc,CAAC,KAAKnJ,gBAAxB,EAA0C;MAE1C,KAAKkI,iBAAL,GAAyBE,UAAU,CAAC;QAAA,OAAWgB;UAAA;;UAAA;YAAA;cAAA;gBAAA;kBAC7C,KAAKvB,cAAL;kBAD6C;kBAKzC,OAAM,KAAK1C,UAAL,EAAN;;gBALyC;kBAAA;kBAGnC/C,OAHmC,0BAG3CH,IAH2C,CAGnCG,OAHmC;kBAIpCkD,YAJoC,0BAI3CpD,KAJ2C;;kBAAA,MAMzC,CAACoD,YAAD,IAAiBlD,OANwB;oBAAA;oBAAA;kBAAA;;kBAAA;kBAOzB,OAAM,KAAK4C,iBAAL,CAAuB5C,OAAO,CAAC6C,aAA/B,CAAN;;gBAPyB;kBAAA;kBAOnC/C,KAPmC,0BAOnCA,KAPmC;kBAQ3C,IAAI,CAACA,KAAL,EAAY,KAAK2F,cAAL,GAAsB,CAAtB;kBACZ,IACE3F,KAAK,YAAYzD,uBAAjB,IACA,KAAKoJ,cAAL,GAAsBxJ,eAAe,CAAC4J,WAFxC,EAIE,KAAKgB,sBAAL,CAA4B5C,wBAAe,CAACgC,cAAhB,EAAkC,KAAKR,cAAvC,IAAwD,GAApF,EAbyC,CAagD;;gBAbhD;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,GAAX;MAAA,CAAD,EAehCsB,KAfgC,CAAnC;MAgBA,IAAI,OAAO,KAAKjB,iBAAL,CAAuBmB,KAA9B,KAAwC,UAA5C,EAAwD,KAAKnB,iBAAL,CAAuBmB,KAAvB;IACzD;;;WAEO,mCAAuB;MAAA;;MAC7B,IAAI,CAAC/J,SAAS,EAAV,IAAgB,EAACkH,MAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAE8C,gBAAT,CAApB,EAA+C;QAC7C,OAAO,KAAP;MACD;;MAED,IAAI;QACF9C,MAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAE8C,gBAAR,CAAyB,kBAAzB,EAA6C;UAAA,OAAWF;YAAA;cAAA;gBAAA;kBAAA;oBAAA,MAClDG,QAAQ,CAACC,eAAT,KAA6B,SADqB;sBAAA;sBAAA;oBAAA;;oBAAA;oBAEpD,OAAM,KAAK3H,iBAAX;;kBAFoD;oBAAA;oBAGpD,OAAM,KAAKW,kBAAL,EAAN;;kBAHoD;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,GAAX;QAAA,CAA7C;MAMD,CAPD,CAOE,OAAON,KAAP,EAAc;QACd4F,OAAO,CAAC5F,KAAR,CAAc,yBAAd,EAAyCA,KAAzC;MACD;IACF;IAED;;;;;;;;;WAMQ,4BACNwB,QADM,EAENrD,OAFM,EAML;MAED,IAAMoJ,SAAS,GAAa,oBAAaC,kBAAkB,CAAChG,QAAD,CAA/B,EAA5B;;MACA,IAAIrD,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEwC,UAAb,EAAyB;QACvB4G,SAAS,CAACE,IAAV,uBAA8BD,kBAAkB,CAACrJ,OAAO,CAACwC,UAAT,CAAhD;MACD;;MACD,IAAIxC,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEsD,MAAb,EAAqB;QACnB8F,SAAS,CAACE,IAAV,kBAAyBD,kBAAkB,CAACrJ,OAAO,CAACsD,MAAT,CAA3C;MACD;;MACD,IAAItD,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEuD,WAAb,EAA0B;QACxB,IAAMgG,KAAK,GAAG,IAAIC,eAAJ,CAAoBxJ,OAAO,CAACuD,WAA5B,CAAd;QACA6F,SAAS,CAACE,IAAV,CAAeC,KAAK,CAACE,QAAN,EAAf;MACD;;MACD,iBAAU,KAAKhK,GAAf,wBAAgC2J,SAAS,CAACM,IAAV,CAAe,GAAf,CAAhC;IACD;;;WAEa,mBAAU9F,MAAV,EAAmC;;;;;;;;;;;;gBAEM,OAAM,KAAKkB,UAAL,EAAN;;;;gBAArCE,qCAANpD;gBAA0BqD,sCAAPpD;;qBACvBoD;;;;;mDACK;kBAAErD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEoD;gBAArB;;;;gBAGF,OAAMxG,QAAQ,CAAC,KAAK6B,KAAN,EAAa,QAAb,YAA0B,KAAKb,GAA/B,sBAA8CmE,MAAM,CAAC+F,QAArD,GAAiE;kBACpF7J,OAAO,EAAE,KAAKA,OADsE;kBAEpF+E,GAAG,EAAE,iBAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE9C,OAAb,MAAoB,IAApB,IAAoBY,aAApB,GAAoB,MAApB,GAAoBA,GAAEkB;gBAFyD,CAAjE,CAAd;;;;;;;;;qBAKHrF,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAIZ;IAED;;;;;;;;;WAMc,iBAAQ+B,MAAR,EAA+B;;;;;;;;;;;;gBAEU,OAAM,KAAKkB,UAAL,EAAN;;;;gBAArCE,qCAANpD;gBAA0BqD,sCAAPpD;;qBACvBoD;;;;;mDACK;kBAAErD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEoD;gBAArB;;;;gBAGe,OAAMxG,QAAQ,CAAC,KAAK6B,KAAN,EAAa,MAAb,YAAwB,KAAKb,GAA7B,eAA4C;kBAChFiD,IAAI,EAAE;oBACJkH,aAAa,EAAEhG,MAAM,CAACiG,YADlB;oBAEJC,WAAW,EAAElG,MAAM,CAACmG,UAFhB;oBAGJC,MAAM,EAAEpG,MAAM,CAACoG;kBAHX,CAD0E;kBAMhFlK,OAAO,EAAE,KAAKA,OANkE;kBAOhF+E,GAAG,EAAE,iBAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE9C,OAAb,MAAoB,IAApB,IAAoBY,aAApB,GAAoB,MAApB,GAAoBA,GAAEkB;gBAPqD,CAA5C,CAAd;;;;gBAAhBjC;gBAAMC;;qBAUVA;;;;;mDACK;kBAAED,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAALA;gBAAd;;;gBAGT,IAAI,UAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEoI,IAAN,MAAU,IAAV,IAAU/G,aAAV,GAAU,MAAV,GAAUA,GAAEgH,OAAhB,EAAyB;kBACvBtI,IAAI,CAACqI,IAAL,CAAUC,OAAV,sCAAgDtI,IAAI,CAACqI,IAAL,CAAUC,OAA1D;gBACD;;mDAEM;kBAAEtI,IAAI,EAAJA,IAAF;kBAAQC,KAAK,EAAE;gBAAf;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAIZ;IAED;;;;;;;;WAKc,iBAAQ+B,MAAR,EAA+B;;;;;;;;;;;;gBAEU,OAAM,KAAKkB,UAAL,EAAN;;;;gBAArCE,qCAANpD;gBAA0BqD,sCAAPpD;;qBACvBoD;;;;;mDACK;kBAAErD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEoD;gBAArB;;;;gBAGe,OAAMxG,QAAQ,CACpC,KAAK6B,KAD+B,EAEpC,MAFoC,YAGjC,KAAKb,GAH4B,sBAGbmE,MAAM,CAAC+F,QAHM,cAIpC;kBACEjH,IAAI,EAAE;oBAAEmD,IAAI,EAAEjC,MAAM,CAACiC,IAAf;oBAAqBsE,YAAY,EAAEvG,MAAM,CAACwG;kBAA1C,CADR;kBAEEtK,OAAO,EAAE,KAAKA,OAFhB;kBAGE+E,GAAG,EAAE,iBAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE9C,OAAb,MAAoB,IAApB,IAAoBY,aAApB,GAAoB,MAApB,GAAoBA,GAAEkB;gBAH7B,CAJoC,CAAd;;;;gBAAhBjC;gBAAMC;;qBAUVA;;;;;mDACK;kBAAED,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAALA;gBAAd;;;;gBAGT,OAAM,KAAKI,YAAL,CAAiBoI;kBACrB7F,UAAU,EAAEwB,IAAI,CAACC,KAAL,CAAWxB,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgC9C,IAAI,CAAC8D;gBAD5B,GAElB9D,IAFkB,CAAjB,CAAN;;;gBAIA,KAAKM,qBAAL,CAA2B,wBAA3B,EAAqDN,IAArD;;mDAEO;kBAAEA,IAAI,EAAJA,IAAF;kBAAQC,KAAK,EAALA;gBAAR;;;;;;qBAEHrD,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAIZ;IAED;;;;;;;WAIc,oBAAW+B,MAAX,EAAqC;;;;;;;;;;;;gBAEI,OAAM,KAAKkB,UAAL,EAAN;;;;gBAArCE,qCAANpD;gBAA0BqD,sCAAPpD;;qBACvBoD;;;;;mDACK;kBAAErD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEoD;gBAArB;;;;gBAGF,OAAMxG,QAAQ,CACnB,KAAK6B,KADc,EAEnB,MAFmB,YAGhB,KAAKb,GAHW,sBAGImE,MAAM,CAAC+F,QAHX,iBAInB;kBACE7J,OAAO,EAAE,KAAKA,OADhB;kBAEE+E,GAAG,EAAE,iBAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE9C,OAAb,MAAoB,IAApB,IAAoBY,aAApB,GAAoB,MAApB,GAAoBA,GAAEkB;gBAF7B,CAJmB,CAAd;;;;;;;;;qBAUHrF,WAAW;;;;;mDACN;kBAAEoD,IAAI,EAAE,IAAR;kBAAcC,KAAK;gBAAnB;;;;;;;;;;;;IAIZ;IAED;;;;;;;;WAKc,6BACZ+B,MADY,EACuB;;;;;;;;;gBAEoB,OAAM,KAAK3C,UAAL,CAAgB;kBAC3E0I,QAAQ,EAAE/F,MAAM,CAAC+F;gBAD0D,CAAhB,CAAN;;;;gBAAzCW,sCAAN1I;gBAA4B2I,uCAAP1I;;qBAGzB0I;;;;;mDACK;kBAAE3I,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAE0I;gBAArB;;;;gBAEF,OAAM,KAAK7J,OAAL,CAAa;kBACxBiJ,QAAQ,EAAE/F,MAAM,CAAC+F,QADO;kBAExBS,WAAW,EAAEE,aAAa,CAACzD,EAFH;kBAGxBhB,IAAI,EAAEjC,MAAM,CAACiC;gBAHW,CAAb,CAAN;;;;;;;;;;;;IAKR;IAED;;;;;;WAGc,wBAAY;;;;;;;;;gBAIpB,OAAM,KAAKL,OAAL,EAAN;;;;gBAFMrC,4BAARvB,KAAQuB;gBACD+B,iCAAPrD;;qBAEEqD;;;;;mDACK;kBAAEtD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEqD;gBAArB;;;gBAGHsF,UAAU,KAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEA,OAAN,KAAiB;gBAC3BP,OAAOO,OAAO,CAACC,MAAR,CACX,UAACC,MAAD;kBAAA,OAAYA,MAAM,CAACZ,WAAP,KAAuB,MAAvB,IAAiCY,MAAM,CAAC/D,MAAP,KAAkB,UAA/D;gBAAA,CADW;mDAIN;kBACL/E,IAAI,EAAE;oBACJ+I,GAAG,EAAEH,OADD;oBAEJP,IAAI,EAAJA;kBAFI,CADD;kBAKLpI,KAAK,EAAE;gBALF;;;;;;;;;IAOR;IAED;;;;;;;WAIc,2CAA+B;;;;;;;;;;;gBAIvC,OAAM,KAAKiD,UAAL,EAAN;;;;gBAFM/C,kCAARH,KAAQG;gBACDkD,uCAAPpD;;qBAEEoD;;;;;mDACK;kBAAErD,IAAI,EAAE,IAAR;kBAAcC,KAAK,EAAEoD;gBAArB;;;oBAEJlD;;;;;mDACI;kBACLH,IAAI,EAAE;oBAAEgJ,YAAY,EAAE,IAAhB;oBAAsBC,SAAS,EAAE,IAAjC;oBAAuCC,4BAA4B,EAAE;kBAArE,CADD;kBAELjJ,KAAK,EAAE;gBAFF;;;gBAMHwD,UAAU,KAAK0F,UAAL,CAAgBhJ,OAAO,CAAC8B,YAAxB;gBAEZ+G,eAAoD;;gBAExD,IAAIvF,OAAO,CAAC2F,GAAZ,EAAiB;kBACfJ,YAAY,GAAGvF,OAAO,CAAC2F,GAAvB;gBACD;;gBAEGH,YAAiDD;gBAE/CK,kBACJ,mBAAO,CAAC9H,IAAR,CAAaqH,OAAb,MAAoB,IAApB,IAAoB7H,aAApB,GAAoB,MAApB,GAAoBA,GAAE8H,MAAF,CAAS,UAACC,MAAD;kBAAA,OAAoBA,MAAM,CAAC/D,MAAP,KAAkB,UAAtC;gBAAA,CAAT,CAApB,MAA8E,IAA9E,IAA8EzD,aAA9E,GAA8EA,EAA9E,GAAkF;;gBAEpF,IAAI+H,eAAe,CAACC,MAAhB,GAAyB,CAA7B,EAAgC;kBAC9BL,SAAS,GAAG,MAAZ;gBACD;;gBAEKC,+BAA+BzF,OAAO,CAAC8F,GAAR,IAAe;mDAE7C;kBAAEvJ,IAAI,EAAE;oBAAEgJ,YAAY,EAAZA,YAAF;oBAAgBC,SAAS,EAATA,SAAhB;oBAA2BC,4BAA4B,EAA5BA;kBAA3B,CAAR;kBAAmEjJ,KAAK,EAAE;gBAA1E;;;;;;;;;IACR;;;;;;SAxwCkB9B,Y","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","NETWORK_FAILURE","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","GoTrueClient","options","Map","settings","inMemorySession","storage","admin","fetch","initialize","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","initializePromise","_initialize","_isImplicitGrantFlow","_getSessionFromUrl","data","error","_removeSession","session","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","credentials","email","password","redirectTo","emailRedirectTo","body","_a","gotrue_meta_security","captcha_token","captchaToken","xform","res","phone","_b","user","_handleProviderSignIn","provider","scopes","queryParams","_c","create_user","shouldCreateUser","_d","params","access_token","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","jwt","getSession","attributes","sessionData","sessionError","userError","timeNow","expiresAt","payload","exp","refreshedSession","getUser","token_type","expires_in","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","replace","href","split","Boolean","accessToken","signOut","status","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","refreshToken","isValidSession","_getUrlForProvider","assign","Infinity","networkRetries","console","log","message","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","RETRY_INTERVAL","refreshingDeferred","promise","_refreshAccessToken","result","resolve","reject","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","value","__awaiter","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","Object","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","_decodeJWT","aal","verifiedFactors","length","amr"],"sources":["C:\\Frontend22\\Projects\\inz\\DevOffers.io\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\r\nimport {\r\n  DEFAULT_HEADERS,\r\n  EXPIRY_MARGIN,\r\n  GOTRUE_URL,\r\n  NETWORK_FAILURE,\r\n  STORAGE_KEY,\r\n} from './lib/constants'\r\nimport {\r\n  AuthError,\r\n  AuthImplicitGrantRedirectError,\r\n  AuthInvalidCredentialsError,\r\n  AuthRetryableFetchError,\r\n  AuthSessionMissingError,\r\n  AuthUnknownError,\r\n  isAuthApiError,\r\n  isAuthError,\r\n} from './lib/errors'\r\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\r\nimport {\r\n  decodeJWTPayload,\r\n  Deferred,\r\n  getItemAsync,\r\n  getParameterByName,\r\n  isBrowser,\r\n  removeItemAsync,\r\n  resolveFetch,\r\n  setItemAsync,\r\n  uuid,\r\n} from './lib/helpers'\r\nimport localStorageAdapter from './lib/local-storage'\r\nimport { polyfillGlobalThis } from './lib/polyfills'\r\nimport type {\r\n  AuthChangeEvent,\r\n  AuthResponse,\r\n  CallRefreshTokenResult,\r\n  GoTrueClientOptions,\r\n  InitializeResult,\r\n  OAuthResponse,\r\n  SSOResponse,\r\n  Provider,\r\n  Session,\r\n  SignInWithOAuthCredentials,\r\n  SignInWithPasswordCredentials,\r\n  SignInWithPasswordlessCredentials,\r\n  SignInWithSSO,\r\n  SignUpWithPasswordCredentials,\r\n  Subscription,\r\n  SupportedStorage,\r\n  User,\r\n  UserAttributes,\r\n  UserResponse,\r\n  VerifyOtpParams,\r\n  GoTrueMFAApi,\r\n  MFAEnrollParams,\r\n  AuthMFAEnrollResponse,\r\n  MFAChallengeParams,\r\n  AuthMFAChallengeResponse,\r\n  MFAUnenrollParams,\r\n  AuthMFAUnenrollResponse,\r\n  MFAVerifyParams,\r\n  AuthMFAVerifyResponse,\r\n  AuthMFAListFactorsResponse,\r\n  AMREntry,\r\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\r\n  AuthenticatorAssuranceLevels,\r\n  Factor,\r\n  MFAChallengeAndVerifyParams,\r\n} from './lib/types'\r\n\r\npolyfillGlobalThis() // Make \"globalThis\" available\r\n\r\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\r\n  url: GOTRUE_URL,\r\n  storageKey: STORAGE_KEY,\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  headers: DEFAULT_HEADERS,\r\n}\r\n\r\nexport default class GoTrueClient {\r\n  /**\r\n   * Namespace for the GoTrue admin methods.\r\n   * These methods should only be used in a trusted server-side environment.\r\n   */\r\n  admin: GoTrueAdminApi\r\n  /**\r\n   * Namespace for the MFA methods.\r\n   */\r\n  mfa: GoTrueMFAApi\r\n  /**\r\n   * The storage key used to identify the values saved in localStorage\r\n   */\r\n  protected storageKey: string\r\n\r\n  /**\r\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\r\n   * Only used if persistSession is false.\r\n   */\r\n  protected inMemorySession: Session | null\r\n\r\n  protected autoRefreshToken: boolean\r\n  protected persistSession: boolean\r\n  protected storage: SupportedStorage\r\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\r\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\r\n  protected networkRetries = 0\r\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\r\n  /**\r\n   * Keeps track of the async client initialization.\r\n   * When null or not yet resolved the auth state is `unknown`\r\n   * Once resolved the the auth state is known and it's save to call any further client methods.\r\n   * Keep extra care to never reject or throw uncaught errors\r\n   */\r\n  protected initializePromise: Promise<InitializeResult> | null = null\r\n  protected detectSessionInUrl = true\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected fetch: Fetch\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\r\n  constructor(options: GoTrueClientOptions) {\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n    this.inMemorySession = null\r\n    this.storageKey = settings.storageKey\r\n    this.autoRefreshToken = settings.autoRefreshToken\r\n    this.persistSession = settings.persistSession\r\n    this.storage = settings.storage || localStorageAdapter\r\n    this.admin = new GoTrueAdminApi({\r\n      url: settings.url,\r\n      headers: settings.headers,\r\n      fetch: settings.fetch,\r\n    })\r\n\r\n    this.url = settings.url\r\n    this.headers = settings.headers\r\n    this.fetch = resolveFetch(settings.fetch)\r\n    this.detectSessionInUrl = settings.detectSessionInUrl\r\n\r\n    this.initialize()\r\n    this.mfa = {\r\n      verify: this._verify.bind(this),\r\n      enroll: this._enroll.bind(this),\r\n      unenroll: this._unenroll.bind(this),\r\n      challenge: this._challenge.bind(this),\r\n      listFactors: this._listFactors.bind(this),\r\n      challengeAndVerify: this._challengeAndVerify.bind(this),\r\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\r\n  initialize(): Promise<InitializeResult> {\r\n    if (!this.initializePromise) {\r\n      this.initializePromise = this._initialize()\r\n    }\r\n\r\n    return this.initializePromise\r\n  }\r\n\r\n  /**\r\n   * IMPORTANT:\r\n   * 1. Never throw in this method, as it is called from the constructor\r\n   * 2. Never return a session from this method as it would be cached over\r\n   *    the whole lifetime of the client\r\n   */\r\n  private async _initialize(): Promise<InitializeResult> {\r\n    if (this.initializePromise) {\r\n      return this.initializePromise\r\n    }\r\n\r\n    try {\r\n      if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\r\n        const { data, error } = await this._getSessionFromUrl()\r\n\r\n        if (error) {\r\n          // failed login attempt via url,\r\n          // remove old session as in verifyOtp, signUp and signInWith*\r\n          await this._removeSession()\r\n\r\n          return { error }\r\n        }\r\n\r\n        const { session, redirectType } = data\r\n\r\n        await this._saveSession(session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n        if (redirectType === 'recovery') {\r\n          this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\r\n        }\r\n\r\n        return { error: null }\r\n      }\r\n\r\n      // no login attempt via callback url try to recover session from storage\r\n      await this._recoverAndRefresh()\r\n      return { error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { error }\r\n      }\r\n\r\n      return {\r\n        error: new AuthUnknownError('Unexpected error during initialization', error),\r\n      }\r\n    } finally {\r\n      this._handleVisibilityChange()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * Be aware that if a user account exists in the system you may get back an\r\n   * error message that attempts to hide this information from the user.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\r\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          redirectTo: options?.emailRedirectTo,\r\n          body: {\r\n            email,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n\r\n      const { data, error } = res\r\n\r\n      if (error || !data) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User | null = data.user\r\n\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user with an email and password or phone and password.\r\n   *\r\n   * Be aware that you may get back an error message that will not distingish\r\n   * between the cases where the account does not exist or that the\r\n   * email/phone and password combination is wrong or that the account can only\r\n   * be accessed via social login.\r\n   */\r\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n      const { data, error } = res\r\n      if (error || !data) return { data: { user: null, session: null }, error }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\r\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\r\n    await this._removeSession()\r\n    return this._handleProviderSignIn(credentials.provider, {\r\n      redirectTo: credentials.options?.redirectTo,\r\n      scopes: credentials.options?.scopes,\r\n      queryParams: credentials.options?.queryParams,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Log in a user using magiclink or a one-time password (OTP).\r\n   *\r\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or, that the account\r\n   * can only be accessed via social login.\r\n   */\r\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      if ('email' in credentials) {\r\n        const { email, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          redirectTo: options?.emailRedirectTo,\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      if ('phone' in credentials) {\r\n        const { phone, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   */\r\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\r\n        headers: this.headers,\r\n        body: {\r\n          ...params,\r\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\r\n        },\r\n        redirectTo: params.options?.redirectTo,\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw 'An error occurred on token verification.'\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User = data.user\r\n\r\n      if (session?.access_token) {\r\n        await this._saveSession(session as Session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts a single-sign on using an enterprise Identity Provider. A\r\n   * successful SSO attempt will redirect the current page to the identity\r\n   * provider authorization page. The redirect URL is implementation and SSO\r\n   * protocol specific.\r\n   *\r\n   * You can use it by providing a SSO domain. Typically you can extract this\r\n   * domain by asking users for their email address. If this domain is\r\n   * registered on the Auth instance the redirect will use that organization's\r\n   * currently active SSO Identity Provider for the login.\r\n   *\r\n   * If you have built an organization-specific login page, you can use the\r\n   * organization's SSO Identity Provider UUID directly instead.\r\n   *\r\n   * This API is experimental and availability is conditional on correct\r\n   * settings on the Auth service.\r\n   *\r\n   * @experimental\r\n   */\r\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\r\n        body: {\r\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\r\n          ...('domain' in params ? { domain: params.domain } : null),\r\n          redirect_to: params.options?.redirectTo ?? undefined,\r\n          ...(params?.options?.captchaToken\r\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\r\n            : null),\r\n          skip_http_redirect: true, // fetch does not handle redirects\r\n        },\r\n        headers: this.headers,\r\n        xform: _ssoResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the session, refreshing it if necessary.\r\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n   */\r\n  async getSession(): Promise<\r\n    | {\r\n        data: {\r\n          session: Session\r\n        }\r\n        error: null\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: AuthError\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: null\r\n      }\r\n  > {\r\n    // make sure we've read the session from the url if there is one\r\n    // save to just await, as long we make sure _initialize() never throws\r\n    await this.initializePromise\r\n\r\n    let currentSession: Session | null = null\r\n\r\n    if (this.persistSession) {\r\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\r\n\r\n      if (maybeSession !== null) {\r\n        if (this._isValidSession(maybeSession)) {\r\n          currentSession = maybeSession\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      }\r\n    } else {\r\n      currentSession = this.inMemorySession\r\n    }\r\n\r\n    if (!currentSession) {\r\n      return { data: { session: null }, error: null }\r\n    }\r\n\r\n    const hasExpired = currentSession.expires_at\r\n      ? currentSession.expires_at <= Date.now() / 1000\r\n      : false\r\n    if (!hasExpired) {\r\n      return { data: { session: currentSession }, error: null }\r\n    }\r\n\r\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n    if (error) {\r\n      return { data: { session: null }, error }\r\n    }\r\n\r\n    return { data: { session }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Gets the current user details if there is an existing session.\r\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n   */\r\n  async getUser(jwt?: string): Promise<UserResponse> {\r\n    try {\r\n      if (!jwt) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        // Default to Authorization header if there is no existing session\r\n        jwt = data.session?.access_token ?? undefined\r\n      }\r\n\r\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        jwt: jwt,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates user data, if there is a logged in user.\r\n   */\r\n  async updateUser(attributes: UserAttributes): Promise<UserResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        throw sessionError\r\n      }\r\n      if (!sessionData.session) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const session: Session = sessionData.session\r\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        body: attributes,\r\n        jwt: session.access_token,\r\n        xform: _userResponse,\r\n      })\r\n      if (userError) throw userError\r\n      session.user = data.user as User\r\n      await this._saveSession(session)\r\n      this._notifyAllSubscribers('USER_UPDATED', session)\r\n\r\n      return { data: { user: session.user }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decodes a JWT (without performing any validation).\r\n   */\r\n  private _decodeJWT(jwt: string): {\r\n    exp?: number\r\n    aal?: AuthenticatorAssuranceLevels | null\r\n    amr?: AMREntry[] | null\r\n  } {\r\n    return decodeJWTPayload(jwt)\r\n  }\r\n\r\n  /**\r\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n   * @param currentSession The current session that minimally contains an access token and refresh token.\r\n   */\r\n  async setSession(currentSession: {\r\n    access_token: string\r\n    refresh_token: string\r\n  }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession.access_token || !currentSession.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const timeNow = Date.now() / 1000\r\n      let expiresAt = timeNow\r\n      let hasExpired = true\r\n      let session: Session | null = null\r\n      const payload = decodeJWTPayload(currentSession.access_token)\r\n      if (payload.exp) {\r\n        expiresAt = payload.exp\r\n        hasExpired = expiresAt <= timeNow\r\n      }\r\n\r\n      if (hasExpired) {\r\n        const { session: refreshedSession, error } = await this._callRefreshToken(\r\n          currentSession.refresh_token\r\n        )\r\n        if (error) {\r\n          return { data: { user: null, session: null }, error: error }\r\n        }\r\n\r\n        if (!refreshedSession) {\r\n          return { data: { user: null, session: null }, error: null }\r\n        }\r\n        session = refreshedSession\r\n      } else {\r\n        const { data, error } = await this.getUser(currentSession.access_token)\r\n        if (error) {\r\n          throw error\r\n        }\r\n        session = {\r\n          access_token: currentSession.access_token,\r\n          refresh_token: currentSession.refresh_token,\r\n          user: data.user,\r\n          token_type: 'bearer',\r\n          expires_in: expiresAt - timeNow,\r\n          expires_at: expiresAt,\r\n        }\r\n        await this._saveSession(session)\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new session, regardless of expiry status.\r\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n   * If the current session's refresh token is invalid, an error will be thrown.\r\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n   */\r\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        currentSession = data.session ?? undefined\r\n      }\r\n\r\n      if (!currentSession?.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      if (!session) {\r\n        return { data: { user: null, session: null }, error: null }\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the session data from a URL string\r\n   */\r\n  private async _getSessionFromUrl(): Promise<\r\n    | {\r\n        data: { session: Session; redirectType: string | null }\r\n        error: null\r\n      }\r\n    | { data: { session: null; redirectType: null }; error: AuthError }\r\n  > {\r\n    try {\r\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\r\n      if (!this._isImplicitGrantFlow()) {\r\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\r\n      }\r\n\r\n      const error_description = getParameterByName('error_description')\r\n      if (error_description) {\r\n        const error_code = getParameterByName('error_code')\r\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\r\n        const error = getParameterByName('error')\r\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\r\n\r\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\r\n      }\r\n\r\n      const provider_token = getParameterByName('provider_token')\r\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\r\n      const access_token = getParameterByName('access_token')\r\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\r\n      const expires_in = getParameterByName('expires_in')\r\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\r\n      const refresh_token = getParameterByName('refresh_token')\r\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\r\n      const token_type = getParameterByName('token_type')\r\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expires_at = timeNow + parseInt(expires_in)\r\n\r\n      const { data, error } = await this.getUser(access_token)\r\n      if (error) throw error\r\n      const user: User = data.user\r\n      const session: Session = {\r\n        provider_token,\r\n        provider_refresh_token,\r\n        access_token,\r\n        expires_in: parseInt(expires_in),\r\n        expires_at,\r\n        refresh_token,\r\n        token_type,\r\n        user,\r\n      }\r\n      const redirectType = getParameterByName('type')\r\n\r\n      // Remove tokens from URL and popping the URL from the back stack\r\n      window.location.replace(window.location.href.split('#')[0])\r\n\r\n      return { data: { session, redirectType }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, redirectType: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n   */\r\n  private _isImplicitGrantFlow(): boolean {\r\n    return (\r\n      isBrowser() &&\r\n      (Boolean(getParameterByName('access_token')) ||\r\n        Boolean(getParameterByName('error_description')))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n   */\r\n  async signOut(): Promise<{ error: AuthError | null }> {\r\n    const { data, error: sessionError } = await this.getSession()\r\n    if (sessionError) {\r\n      return { error: sessionError }\r\n    }\r\n    const accessToken = data.session?.access_token\r\n    if (accessToken) {\r\n      const { error } = await this.admin.signOut(accessToken)\r\n      if (error) {\r\n        // ignore 404s since user might not exist anymore\r\n        // ignore 401s since an invalid or expired JWT should sign out the current session\r\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\r\n          return { error }\r\n        }\r\n      }\r\n    }\r\n    await this._removeSession()\r\n    this._notifyAllSubscribers('SIGNED_OUT', null)\r\n    return { error: null }\r\n  }\r\n\r\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @param callback A callback function to be invoked when an auth event happens.\r\n   */\r\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\r\n    data: { subscription: Subscription }\r\n  } {\r\n    const id: string = uuid()\r\n    const subscription: Subscription = {\r\n      id,\r\n      callback,\r\n      unsubscribe: () => {\r\n        this.stateChangeEmitters.delete(id)\r\n      },\r\n    }\r\n\r\n    this.stateChangeEmitters.set(id, subscription)\r\n\r\n    return { data: { subscription } }\r\n  }\r\n\r\n  /**\r\n   * Sends a password reset request to an email address.\r\n   * @param email The email address of the user.\r\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n   */\r\n  async resetPasswordForEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<\r\n    | {\r\n        data: {}\r\n        error: null\r\n      }\r\n    | { data: null; error: AuthError }\r\n  > {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\r\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        headers: this.headers,\r\n        redirectTo: options.redirectTo,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\r\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\r\n        body: { refresh_token: refreshToken },\r\n        headers: this.headers,\r\n        xform: _sessionResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\r\n    const isValidSession =\r\n      typeof maybeSession === 'object' &&\r\n      maybeSession !== null &&\r\n      'access_token' in maybeSession &&\r\n      'refresh_token' in maybeSession &&\r\n      'expires_at' in maybeSession\r\n\r\n    return isValidSession\r\n  }\r\n\r\n  private _handleProviderSignIn(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n    } = {}\r\n  ) {\r\n    const url: string = this._getUrlForProvider(provider, {\r\n      redirectTo: options.redirectTo,\r\n      scopes: options.scopes,\r\n      queryParams: options.queryParams,\r\n    })\r\n    // try to open on the browser\r\n    if (isBrowser()) {\r\n      window.location.assign(url)\r\n    }\r\n    return { data: { provider, url }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\r\n  private async _recoverAndRefresh() {\r\n    try {\r\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\r\n      if (!this._isValidSession(currentSession)) {\r\n        if (currentSession !== null) {\r\n          await this._removeSession()\r\n        }\r\n\r\n        return\r\n      }\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\r\n        if (this.autoRefreshToken && currentSession.refresh_token) {\r\n          this.networkRetries++\r\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\r\n          if (error) {\r\n            console.log(error.message)\r\n            if (\r\n              error instanceof AuthRetryableFetchError &&\r\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\r\n            ) {\r\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\r\n              this.refreshTokenTimer = setTimeout(\r\n                () => this._recoverAndRefresh(),\r\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\r\n              )\r\n              return\r\n            }\r\n            await this._removeSession()\r\n          }\r\n          this.networkRetries = 0\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      } else {\r\n        if (this.persistSession) {\r\n          await this._saveSession(currentSession)\r\n        }\r\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return\r\n    }\r\n  }\r\n\r\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\r\n    // refreshing is already in progress\r\n    if (this.refreshingDeferred) {\r\n      return this.refreshingDeferred.promise\r\n    }\r\n\r\n    try {\r\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\r\n\r\n      if (!refreshToken) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const { data, error } = await this._refreshAccessToken(refreshToken)\r\n      if (error) throw error\r\n      if (!data.session) throw new AuthSessionMissingError()\r\n\r\n      await this._saveSession(data.session)\r\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\r\n\r\n      const result = { session: data.session, error: null }\r\n\r\n      this.refreshingDeferred.resolve(result)\r\n\r\n      return result\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        const result = { session: null, error }\r\n\r\n        this.refreshingDeferred?.resolve(result)\r\n\r\n        return result\r\n      }\r\n\r\n      this.refreshingDeferred?.reject(error)\r\n      throw error\r\n    } finally {\r\n      this.refreshingDeferred = null\r\n    }\r\n  }\r\n\r\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null) {\r\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\r\n  }\r\n\r\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\r\n  private async _saveSession(session: Session) {\r\n    if (!this.persistSession) {\r\n      this.inMemorySession = session\r\n    }\r\n\r\n    const expiresAt = session.expires_at\r\n    if (expiresAt) {\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expiresIn = expiresAt - timeNow\r\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\r\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\r\n    }\r\n\r\n    if (this.persistSession && session.expires_at) {\r\n      await this._persistSession(session)\r\n    }\r\n  }\r\n\r\n  private _persistSession(currentSession: Session) {\r\n    return setItemAsync(this.storage, this.storageKey, currentSession)\r\n  }\r\n\r\n  private async _removeSession() {\r\n    if (this.persistSession) {\r\n      await removeItemAsync(this.storage, this.storageKey)\r\n    } else {\r\n      this.inMemorySession = null\r\n    }\r\n\r\n    if (this.refreshTokenTimer) {\r\n      clearTimeout(this.refreshTokenTimer)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear and re-create refresh token timer\r\n   * @param value time intervals in milliseconds.\r\n   * @param session The current session.\r\n   */\r\n  private _startAutoRefreshToken(value: number) {\r\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\r\n    if (value <= 0 || !this.autoRefreshToken) return\r\n\r\n    this.refreshTokenTimer = setTimeout(async () => {\r\n      this.networkRetries++\r\n      const {\r\n        data: { session },\r\n        error: sessionError,\r\n      } = await this.getSession()\r\n      if (!sessionError && session) {\r\n        const { error } = await this._callRefreshToken(session.refresh_token)\r\n        if (!error) this.networkRetries = 0\r\n        if (\r\n          error instanceof AuthRetryableFetchError &&\r\n          this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\r\n        )\r\n          this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\r\n      }\r\n    }, value)\r\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\r\n  }\r\n\r\n  private _handleVisibilityChange() {\r\n    if (!isBrowser() || !window?.addEventListener) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      window?.addEventListener('visibilitychange', async () => {\r\n        if (document.visibilityState === 'visible') {\r\n          await this.initializePromise\r\n          await this._recoverAndRefresh()\r\n        }\r\n      })\r\n    } catch (error) {\r\n      console.error('_handleVisibilityChange', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n   */\r\n  private _getUrlForProvider(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n    }\r\n  ) {\r\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\r\n    if (options?.redirectTo) {\r\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\r\n    }\r\n    if (options?.scopes) {\r\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\r\n    }\r\n    if (options?.queryParams) {\r\n      const query = new URLSearchParams(options.queryParams)\r\n      urlParams.push(query.toString())\r\n    }\r\n    return `${this.url}/authorize?${urlParams.join('&')}`\r\n  }\r\n\r\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enrolls a factor\r\n   * @param friendlyName Human readable name assigned to a device\r\n   * @param factorType device which we're validating against. Can only be TOTP for now.\r\n   * @param issuer domain which the user is enrolling with\r\n   */\r\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\r\n        body: {\r\n          friendly_name: params.friendlyName,\r\n          factor_type: params.factorType,\r\n          issuer: params.issuer,\r\n        },\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      if (data?.totp?.qr_code) {\r\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\r\n      }\r\n\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates a device as part of the enrollment step.\r\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n   * @param code Code Generated by an authenticator device\r\n   */\r\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/verify`,\r\n        {\r\n          body: { code: params.code, challenge_id: params.challengeId },\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      await this._saveSession({\r\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\r\n        ...data,\r\n      })\r\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\r\n\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a challenge which a user can verify against\r\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n   */\r\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/challenge`,\r\n        {\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a challenge and immediately verifies it\r\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\r\n   * @param code Code Generated by an authenticator device\r\n   */\r\n  private async _challengeAndVerify(\r\n    params: MFAChallengeAndVerifyParams\r\n  ): Promise<AuthMFAVerifyResponse> {\r\n    const { data: challengeData, error: challengeError } = await this._challenge({\r\n      factorId: params.factorId,\r\n    })\r\n    if (challengeError) {\r\n      return { data: null, error: challengeError }\r\n    }\r\n    return await this._verify({\r\n      factorId: params.factorId,\r\n      challengeId: challengeData.id,\r\n      code: params.code,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Displays all devices for a given user\r\n   */\r\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await this.getUser()\r\n    if (userError) {\r\n      return { data: null, error: userError }\r\n    }\r\n\r\n    const factors = user?.factors || []\r\n    const totp = factors.filter(\r\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\r\n    )\r\n\r\n    return {\r\n      data: {\r\n        all: factors,\r\n        totp,\r\n      },\r\n      error: null,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current and next authenticator assurance level (AAL)\r\n   * and the current authentication methods for the session (AMR)\r\n   */\r\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\r\n    const {\r\n      data: { session },\r\n      error: sessionError,\r\n    } = await this.getSession()\r\n    if (sessionError) {\r\n      return { data: null, error: sessionError }\r\n    }\r\n    if (!session) {\r\n      return {\r\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\r\n        error: null,\r\n      }\r\n    }\r\n\r\n    const payload = this._decodeJWT(session.access_token)\r\n\r\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\r\n\r\n    if (payload.aal) {\r\n      currentLevel = payload.aal\r\n    }\r\n\r\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\r\n\r\n    const verifiedFactors =\r\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\r\n\r\n    if (verifiedFactors.length > 0) {\r\n      nextLevel = 'aal2'\r\n    }\r\n\r\n    const currentAuthenticationMethods = payload.amr || []\r\n\r\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}